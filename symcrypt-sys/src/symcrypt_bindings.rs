/* automatically generated by rust-bindgen 0.65.1 */

pub const SYMCRYPT_CODE_VERSION_API: u32 = 103;
pub const SYMCRYPT_CODE_VERSION_MINOR: u32 = 1;
pub const SYMCRYPT_CODE_VERSION_PATCH: u32 = 0;
pub const SYMCRYPT_DEBUG: u32 = 0;
pub const SYMCRYPT_API_VERSION: u32 = 6750209;
pub const SYMCRYPT_MS_VC: u32 = 0;
pub const SYMCRYPT_APPLE_CC: u32 = 0;
pub const SYMCRYPT_GNUC: u32 = 0;
pub const SYMCRYPT_ANYSIZE_ARRAY: u32 = 1;
pub const SYMCRYPT_CPU_X86: u32 = 0;
pub const SYMCRYPT_CPU_AMD64: u32 = 0;
pub const SYMCRYPT_CPU_ARM: u32 = 0;
pub const SYMCRYPT_CPU_ARM64: u32 = 0;
pub const SYMCRYPT_CPU_UNKNOWN: u32 = 0;
pub const SYMCRYPT_ALIGN_VALUE: u32 = 16;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const SIZE_T_MAX: i32 = -1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const SYMCRYPT_CPU_FEATURE_SSE2: u32 = 1;
pub const SYMCRYPT_CPU_FEATURE_SSSE3: u32 = 2;
pub const SYMCRYPT_CPU_FEATURE_AESNI: u32 = 4;
pub const SYMCRYPT_CPU_FEATURE_PCLMULQDQ: u32 = 8;
pub const SYMCRYPT_CPU_FEATURE_AVX2: u32 = 16;
pub const SYMCRYPT_CPU_FEATURE_SAVEXMM_NOFAIL: u32 = 32;
pub const SYMCRYPT_CPU_FEATURE_SHANI: u32 = 64;
pub const SYMCRYPT_CPU_FEATURE_BMI2: u32 = 128;
pub const SYMCRYPT_CPU_FEATURE_ADX: u32 = 256;
pub const SYMCRYPT_CPU_FEATURE_RDRAND: u32 = 512;
pub const SYMCRYPT_CPU_FEATURE_RDSEED: u32 = 1024;
pub const SYMCRYPT_CPU_FEATURE_VAES: u32 = 2048;
pub const SYMCRYPT_CPU_FEATURE_AVX512: u32 = 4096;
pub const SYMCRYPT_CPU_FEATURE_CMPXCHG16B: u32 = 8192;
pub const SYMCRYPT_PARALLEL_SHA256_MIN_PARALLELISM: u32 = 2;
pub const SYMCRYPT_PARALLEL_SHA256_MAX_PARALLELISM: u32 = 8;
pub const SYMCRYPT_SIMD_ELEMENT_SIZE: u32 = 32;
pub const SYMCRYPT_PARALLEL_SHA256_FIXED_SCRATCH: u32 = 2478;
pub const SYMCRYPT_PARALLEL_SHA384_FIXED_SCRATCH: u32 = 2990;
pub const SYMCRYPT_PARALLEL_SHA512_FIXED_SCRATCH: u32 = 2990;
pub const SYMCRYPT_CCM_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_GF128_FIELD_SIZE: u32 = 128;
pub const SYMCRYPT_GF128_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_GCM_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_GCM_MAX_KEY_SIZE: u32 = 32;
pub const SYMCRYPT_GCM_BLOCK_MOD_MASK: u32 = 15;
pub const SYMCRYPT_GCM_BLOCK_ROUND_MASK: i32 = -16;
pub const SYMCRYPT_GHASH_ALLOW_XMM: u32 = 1;
pub const SYMCRYPT_GHASH_ALLOW_NEON: u32 = 0;
pub const SYMCRYPT_MAX_BLOCK_SIZE: u32 = 32;
pub const SYMCRYPT_FLAG_SESSION_ENCRYPT: u32 = 1;
pub const SYMCRYPT_SESSION_MAX_MESSAGE_NUMBER: i64 = -4294967296;
pub const SYMCRYPT_USE_CAS128: u32 = 1;
pub const SYMCRYPT_MD2_STATE_EXPORT_SIZE: u32 = 80;
pub const SYMCRYPT_MD4_STATE_EXPORT_SIZE: u32 = 116;
pub const SYMCRYPT_MD5_STATE_EXPORT_SIZE: u32 = 116;
pub const SYMCRYPT_SHA1_STATE_EXPORT_SIZE: u32 = 120;
pub const SYMCRYPT_SHA256_STATE_EXPORT_SIZE: u32 = 132;
pub const SYMCRYPT_SHA384_STATE_EXPORT_SIZE: u32 = 236;
pub const SYMCRYPT_SHA512_STATE_EXPORT_SIZE: u32 = 236;
pub const SYMCRYPT_SHA3_STATE_EXPORT_SIZE: u32 = 234;
pub const SYMCRYPT_SHA3_256_STATE_EXPORT_SIZE: u32 = 234;
pub const SYMCRYPT_SHA3_384_STATE_EXPORT_SIZE: u32 = 234;
pub const SYMCRYPT_SHA3_512_STATE_EXPORT_SIZE: u32 = 234;
pub const SYMCRYPT_FDEF_DIGIT_SIZE: u32 = 64;
pub const SYMCRYPT_ASYM_ALIGN_VALUE: u32 = 32;
pub const SYMCRYPT_ANYSIZE: u32 = 1;
pub const SYMCRYPT_FDEF_DIGIT_BITS: u32 = 512;
pub const SYMCRYPT_FDEF_MAX_WINDOW_MODEXP: u32 = 6;
pub const SYMCRYPT_RSAKEY_MAX_NUMOF_PRIMES: u32 = 2;
pub const SYMCRYPT_RSAKEY_MAX_NUMOF_PUBEXPS: u32 = 1;
pub const SYMCRYPT_RSAKEY_MIN_BITSIZE_MODULUS: u32 = 256;
pub const SYMCRYPT_RSAKEY_MAX_BITSIZE_MODULUS: u32 = 65536;
pub const SYMCRYPT_RSAKEY_FIPS_MIN_BITSIZE_MODULUS: u32 = 1024;
pub const SYMCRYPT_RSAKEY_MIN_BITSIZE_PRIME: u32 = 128;
pub const SYMCRYPT_RSAKEY_MAX_BITSIZE_PRIME: u32 = 32768;
pub const SYMCRYPT_DLGROUP_MIN_BITSIZE_P: u32 = 32;
pub const SYMCRYPT_DLGROUP_MIN_BITSIZE_Q: u32 = 31;
pub const SYMCRYPT_ECPOINT_FORMAT_MAX_LENGTH: u32 = 4;
pub const SYMCRYPT_ECURVE_SW_DEF_WINDOW: u32 = 6;
pub const SYMCRYPT_ECURVE_SW_MAX_NPRECOMP_POINTS: u32 = 64;
pub const SYMCRYPT_ECURVE_MIN_BITSIZE_FMOD: u32 = 32;
pub const SYMCRYPT_ECURVE_MIN_BITSIZE_GORD: u32 = 32;
pub const SYMCRYPT_ECURVE_MAX_COFACTOR_POWER: u32 = 8;
pub const SYMCRYPT_INTERNAL_ECURVE_VERSION_LATEST: u32 = 1;
pub const SYMCRYPT_WIPE_FUNCTION_LIMIT: u32 = 64;
pub const SYMCRYPT_DO_FIPS_SELFTESTS: u32 = 0;
pub const SYMCRYPT_SELFTEST_KEY_DSA: u32 = 1;
pub const SYMCRYPT_SELFTEST_KEY_ECDSA: u32 = 1;
pub const SYMCRYPT_SELFTEST_KEY_RSA_SIGN: u32 = 1;
pub const SYMCRYPT_MD2_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_MD2_INPUT_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_MD4_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_MD4_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_MD5_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_MD5_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_SHA1_RESULT_SIZE: u32 = 20;
pub const SYMCRYPT_SHA1_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_SHA256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA256_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_SHA384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA384_INPUT_BLOCK_SIZE: u32 = 128;
pub const SYMCRYPT_SHA512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_SHA512_INPUT_BLOCK_SIZE: u32 = 128;
pub const SYMCRYPT_SHA3_256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHA3_256_INPUT_BLOCK_SIZE: u32 = 136;
pub const SYMCRYPT_SHA3_384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_SHA3_384_INPUT_BLOCK_SIZE: u32 = 104;
pub const SYMCRYPT_SHA3_512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_SHA3_512_INPUT_BLOCK_SIZE: u32 = 72;
pub const SYMCRYPT_SHAKE128_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_SHAKE128_INPUT_BLOCK_SIZE: u32 = 168;
pub const SYMCRYPT_SHAKE256_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_SHAKE256_INPUT_BLOCK_SIZE: u32 = 136;
pub const SYMCRYPT_CSHAKE128_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_CSHAKE128_INPUT_BLOCK_SIZE: u32 = 168;
pub const SYMCRYPT_CSHAKE256_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_CSHAKE256_INPUT_BLOCK_SIZE: u32 = 136;
pub const SYMCRYPT_HMAC_MD5_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_HMAC_MD5_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_HMAC_SHA1_RESULT_SIZE: u32 = 20;
pub const SYMCRYPT_HMAC_SHA1_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_HMAC_SHA256_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_HMAC_SHA256_INPUT_BLOCK_SIZE: u32 = 64;
pub const SYMCRYPT_HMAC_SHA384_RESULT_SIZE: u32 = 48;
pub const SYMCRYPT_HMAC_SHA384_INPUT_BLOCK_SIZE: u32 = 128;
pub const SYMCRYPT_HMAC_SHA512_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_HMAC_SHA512_INPUT_BLOCK_SIZE: u32 = 128;
pub const SYMCRYPT_AES_CMAC_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_AES_CMAC_INPUT_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_KMAC128_RESULT_SIZE: u32 = 32;
pub const SYMCRYPT_KMAC128_INPUT_BLOCK_SIZE: u32 = 168;
pub const SYMCRYPT_KMAC256_RESULT_SIZE: u32 = 64;
pub const SYMCRYPT_KMAC256_INPUT_BLOCK_SIZE: u32 = 136;
pub const SYMCRYPT_POLY1305_RESULT_SIZE: u32 = 16;
pub const SYMCRYPT_POLY1305_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_POLY1305_KEY_SIZE: u32 = 32;
pub const SYMCRYPT_MARVIN32_RESULT_SIZE: u32 = 8;
pub const SYMCRYPT_MARVIN32_SEED_SIZE: u32 = 8;
pub const SYMCRYPT_MARVIN32_INPUT_BLOCK_SIZE: u32 = 4;
pub const SYMCRYPT_AES_BLOCK_SIZE: u32 = 16;
pub const SYMCRYPT_AES_SELFTEST_BASE: u32 = 1;
pub const SYMCRYPT_AES_SELFTEST_ECB: u32 = 2;
pub const SYMCRYPT_AES_SELFTEST_CBC: u32 = 4;
pub const SYMCRYPT_AES_SELFTEST_CBCMAC: u32 = 8;
pub const SYMCRYPT_AES_SELFTEST_CTR: u32 = 16;
pub const SYMCRYPT_AES_SELFTEST_ALL: u32 = 31;
pub const SYMCRYPT_DES_BLOCK_SIZE: u32 = 8;
pub const SYMCRYPT_3DES_BLOCK_SIZE: u32 = 8;
pub const SYMCRYPT_DESX_BLOCK_SIZE: u32 = 8;
pub const SYMCRYPT_RC2_BLOCK_SIZE: u32 = 8;
pub const SYMCRYPT_TLS_MAX_LABEL_SIZE: u32 = 256;
pub const SYMCRYPT_TLS_MAX_SEED_SIZE: u32 = 256;
pub const SYMCRYPT_SSHKDF_IV_CLIENT_TO_SERVER: u32 = 65;
pub const SYMCRYPT_SSHKDF_IV_SERVER_TO_CLIENT: u32 = 66;
pub const SYMCRYPT_SSHKDF_ENCRYPTION_KEY_CLIENT_TO_SERVER: u32 = 67;
pub const SYMCRYPT_SSHKDF_ENCRYPTION_KEY_SERVER_TO_CLIENT: u32 = 68;
pub const SYMCRYPT_SSHKDF_INTEGRITY_KEY_CLIENT_TO_SERVER: u32 = 69;
pub const SYMCRYPT_SSHKDF_INTEGRITY_KEY_SERVER_TO_CLIENT: u32 = 70;
pub const SYMCRYPT_SRTP_ENCRYPTION_KEY: u32 = 0;
pub const SYMCRYPT_SRTP_AUTHENTICATION_KEY: u32 = 1;
pub const SYMCRYPT_SRTP_SALTING_KEY: u32 = 2;
pub const SYMCRYPT_SRTCP_ENCRYPTION_KEY: u32 = 3;
pub const SYMCRYPT_SRTCP_AUTHENTICATION_KEY: u32 = 4;
pub const SYMCRYPT_SRTCP_SALTING_KEY: u32 = 5;
pub const SYMCRYPT_RNG_AES_MIN_INSTANTIATE_SIZE: u32 = 48;
pub const SYMCRYPT_RNG_AES_MIN_RESEED_SIZE: u32 = 32;
pub const SYMCRYPT_RNG_AES_MAX_SEED_SIZE: u32 = 256;
pub const SYMCRYPT_RDRAND_RESEED_SIZE: u32 = 8192;
pub const SYMCRYPT_FLAG_KEY_NO_FIPS: u32 = 256;
pub const SYMCRYPT_FLAG_KEY_MINIMAL_VALIDATION: u32 = 512;
pub const SYMCRYPT_FLAG_DLKEY_DSA: u32 = 4096;
pub const SYMCRYPT_FLAG_DLKEY_DH: u32 = 8192;
pub const SYMCRYPT_FLAG_ECKEY_ECDSA: u32 = 4096;
pub const SYMCRYPT_FLAG_ECKEY_ECDH: u32 = 8192;
pub const SYMCRYPT_FLAG_RSAKEY_SIGN: u32 = 4096;
pub const SYMCRYPT_FLAG_RSAKEY_ENCRYPT: u32 = 8192;
pub const SYMCRYPT_FLAG_DLKEY_GEN_MODP: u32 = 1;
pub const SYMCRYPT_FLAG_ECDSA_NO_TRUNCATION: u32 = 8;
pub const SYMCRYPT_FLAG_RSA_PKCS1_NO_ASN1: u32 = 1;
pub const SYMCRYPT_FLAG_RSA_PKCS1_OPTIONAL_HASH_OID: u32 = 2;
pub const SYMCRYPT_MD5_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA1_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA256_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA384_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA512_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA3_256_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA3_384_OID_COUNT: u32 = 2;
pub const SYMCRYPT_SHA3_512_OID_COUNT: u32 = 2;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub const SYMCRYPT_ERROR_SYMCRYPT_NO_ERROR: SYMCRYPT_ERROR = 0;
pub const SYMCRYPT_ERROR_SYMCRYPT_UNUSED: SYMCRYPT_ERROR = 32768;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_KEY_SIZE: SYMCRYPT_ERROR = 32769;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_BLOCK_SIZE: SYMCRYPT_ERROR = 32770;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_DATA_SIZE: SYMCRYPT_ERROR = 32771;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_NONCE_SIZE: SYMCRYPT_ERROR = 32772;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_TAG_SIZE: SYMCRYPT_ERROR = 32773;
pub const SYMCRYPT_ERROR_SYMCRYPT_WRONG_ITERATION_COUNT: SYMCRYPT_ERROR = 32774;
pub const SYMCRYPT_ERROR_SYMCRYPT_AUTHENTICATION_FAILURE: SYMCRYPT_ERROR = 32775;
pub const SYMCRYPT_ERROR_SYMCRYPT_EXTERNAL_FAILURE: SYMCRYPT_ERROR = 32776;
pub const SYMCRYPT_ERROR_SYMCRYPT_FIPS_FAILURE: SYMCRYPT_ERROR = 32777;
pub const SYMCRYPT_ERROR_SYMCRYPT_HARDWARE_FAILURE: SYMCRYPT_ERROR = 32778;
pub const SYMCRYPT_ERROR_SYMCRYPT_NOT_IMPLEMENTED: SYMCRYPT_ERROR = 32779;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_BLOB: SYMCRYPT_ERROR = 32780;
pub const SYMCRYPT_ERROR_SYMCRYPT_BUFFER_TOO_SMALL: SYMCRYPT_ERROR = 32781;
pub const SYMCRYPT_ERROR_SYMCRYPT_INVALID_ARGUMENT: SYMCRYPT_ERROR = 32782;
pub const SYMCRYPT_ERROR_SYMCRYPT_MEMORY_ALLOCATION_FAILURE: SYMCRYPT_ERROR = 32783;
pub const SYMCRYPT_ERROR_SYMCRYPT_SIGNATURE_VERIFICATION_FAILURE: SYMCRYPT_ERROR = 32784;
pub const SYMCRYPT_ERROR_SYMCRYPT_INCOMPATIBLE_FORMAT: SYMCRYPT_ERROR = 32785;
pub const SYMCRYPT_ERROR_SYMCRYPT_VALUE_TOO_LARGE: SYMCRYPT_ERROR = 32786;
pub const SYMCRYPT_ERROR_SYMCRYPT_SESSION_REPLAY_FAILURE: SYMCRYPT_ERROR = 32787;
pub type SYMCRYPT_ERROR = ::std::os::raw::c_uint;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_NULL: _SYMCRYPT_ECURVE_TYPE = 0;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_SHORT_WEIERSTRASS: _SYMCRYPT_ECURVE_TYPE = 1;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_TWISTED_EDWARDS: _SYMCRYPT_ECURVE_TYPE = 2;
pub const _SYMCRYPT_ECURVE_TYPE_SYMCRYPT_ECURVE_TYPE_MONTGOMERY: _SYMCRYPT_ECURVE_TYPE = 3;
pub type _SYMCRYPT_ECURVE_TYPE = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECURVE_TYPE as SYMCRYPT_ECURVE_TYPE;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_NONE: _SYMCRYPT_DLGROUP_FIPS = 0;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_186_2: _SYMCRYPT_DLGROUP_FIPS = 1;
pub const _SYMCRYPT_DLGROUP_FIPS_SYMCRYPT_DLGROUP_FIPS_186_3: _SYMCRYPT_DLGROUP_FIPS = 2;
pub type _SYMCRYPT_DLGROUP_FIPS = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_DLGROUP_FIPS as SYMCRYPT_DLGROUP_FIPS;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_NONE:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 0;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_IKE_3526:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 1;
pub const _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE_TLS_7919:
    _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = 2;
pub type _SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE as SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type BYTE = u8;
pub type SIZE_T = usize;
pub type INT_PTR = ::std::os::raw::c_long;
pub type PINT_PTR = *mut ::std::os::raw::c_long;
pub type UINT_PTR = ::std::os::raw::c_ulong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulong;
pub type LONG_PTR = ::std::os::raw::c_long;
pub type PLONG_PTR = *mut ::std::os::raw::c_long;
pub type ULONG_PTR = ::std::os::raw::c_ulong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type ULONG = ::std::os::raw::c_ulong;
pub type INT8 = i8;
pub type PINT8 = *mut i8;
pub type INT16 = i16;
pub type PINT16 = *mut i16;
pub type INT32 = i32;
pub type PINT32 = *mut i32;
pub type INT64 = i64;
pub type PINT64 = *mut i64;
pub type UINT8 = u8;
pub type PUINT8 = *mut u8;
pub type UINT16 = u16;
pub type PUINT16 = *mut u16;
pub type UINT32 = u32;
pub type PUINT32 = *mut u32;
pub type UINT64 = u64;
pub type PUINT64 = *mut u64;
pub type ULONG32 = u32;
pub type PULONG32 = *mut u32;
pub type CHAR = ::std::os::raw::c_char;
pub type PBYTE = *mut BYTE;
pub type PCBYTE = *const BYTE;
pub type PCUINT16 = *const UINT16;
pub type PCUINT32 = *const UINT32;
pub type PCUINT64 = *const UINT64;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type PCVOID = *const ::std::os::raw::c_void;
pub type BOOLEAN = BYTE;
pub type __C_ASSERT__ = [::std::os::raw::c_char; 1usize];
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter {
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter() {
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn __cpuid(CPUInfo: *mut ::std::os::raw::c_int, InfoType: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __cpuidex(
        CPUInfo: *mut ::std::os::raw::c_int,
        InfoType: ::std::os::raw::c_int,
        ECXValue: ::std::os::raw::c_int,
    );
}
pub type SYMCRYPT_CPU_FEATURES = UINT32;
extern "C" {
    pub static mut g_SymCryptCpuFeaturesNotPresent: SYMCRYPT_CPU_FEATURES;
}
extern "C" {
    pub fn SymCryptCpuFeaturesNeverPresent() -> SYMCRYPT_CPU_FEATURES;
}
pub type SYMCRYPT_BLOCKCIPHER = _SYMCRYPT_BLOCKCIPHER;
pub type PSYMCRYPT_BLOCKCIPHER = *mut _SYMCRYPT_BLOCKCIPHER;
pub type PCSYMCRYPT_BLOCKCIPHER = *const SYMCRYPT_BLOCKCIPHER;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_COMMON_HASH_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_COMMON_HASH_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_COMMON_HASH_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_COMMON_HASH_STATE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_COMMON_HASH_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_COMMON_HASH_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_COMMON_HASH_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_COMMON_HASH_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_COMMON_HASH_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_COMMON_HASH_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_COMMON_HASH_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_COMMON_HASH_STATE),
            "::",
            stringify!(buffer)
        )
    );
}
pub type SYMCRYPT_COMMON_HASH_STATE = _SYMCRYPT_COMMON_HASH_STATE;
pub type PSYMCRYPT_COMMON_HASH_STATE = *mut _SYMCRYPT_COMMON_HASH_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD2_CHAINING_STATE {
    pub C: [BYTE; 16usize],
    pub X: [BYTE; 48usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD2_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD2_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD2_CHAINING_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD2_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD2_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD2_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).C) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_CHAINING_STATE),
            "::",
            stringify!(C)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).X) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_CHAINING_STATE),
            "::",
            stringify!(X)
        )
    );
}
pub type SYMCRYPT_MD2_CHAINING_STATE = _SYMCRYPT_MD2_CHAINING_STATE;
pub type PSYMCRYPT_MD2_CHAINING_STATE = *mut _SYMCRYPT_MD2_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD2_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 16usize],
    pub chain: SYMCRYPT_MD2_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD2_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD2_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD2_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD2_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD2_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD2_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD2_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_MD2_STATE = _SYMCRYPT_MD2_STATE;
pub type PSYMCRYPT_MD2_STATE = *mut _SYMCRYPT_MD2_STATE;
pub type PCSYMCRYPT_MD2_STATE = *const SYMCRYPT_MD2_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD4_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD4_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD4_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD4_CHAINING_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD4_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD4_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD4_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_MD4_CHAINING_STATE = _SYMCRYPT_MD4_CHAINING_STATE;
pub type PSYMCRYPT_MD4_CHAINING_STATE = *mut _SYMCRYPT_MD4_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD4_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD4_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD4_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD4_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD4_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD4_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD4_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD4_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD4_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_MD4_STATE = _SYMCRYPT_MD4_STATE;
pub type PSYMCRYPT_MD4_STATE = *mut _SYMCRYPT_MD4_STATE;
pub type PCSYMCRYPT_MD4_STATE = *const SYMCRYPT_MD4_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD5_CHAINING_STATE {
    pub H: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD5_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD5_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_MD5_CHAINING_STATE = _SYMCRYPT_MD5_CHAINING_STATE;
pub type PSYMCRYPT_MD5_CHAINING_STATE = *mut _SYMCRYPT_MD5_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MD5_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_MD5_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MD5_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MD5_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MD5_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MD5_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MD5_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MD5_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MD5_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_MD5_STATE = _SYMCRYPT_MD5_STATE;
pub type PSYMCRYPT_MD5_STATE = *mut _SYMCRYPT_MD5_STATE;
pub type PCSYMCRYPT_MD5_STATE = *const SYMCRYPT_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_CHAINING_STATE {
    pub H: [UINT32; 5usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA1_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA1_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA1_CHAINING_STATE = _SYMCRYPT_SHA1_CHAINING_STATE;
pub type PSYMCRYPT_SHA1_CHAINING_STATE = *mut _SYMCRYPT_SHA1_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA1_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA1_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA1_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA1_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA1_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA1_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA1_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA1_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA1_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_SHA1_STATE = _SYMCRYPT_SHA1_STATE;
pub type PSYMCRYPT_SHA1_STATE = *mut _SYMCRYPT_SHA1_STATE;
pub type PCSYMCRYPT_SHA1_STATE = *const SYMCRYPT_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_CHAINING_STATE {
    pub H: [UINT32; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA256_CHAINING_STATE = _SYMCRYPT_SHA256_CHAINING_STATE;
pub type PSYMCRYPT_SHA256_CHAINING_STATE = *mut _SYMCRYPT_SHA256_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA256_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 64usize],
    pub chain: SYMCRYPT_SHA256_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA256_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA256_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_SHA256_STATE = _SYMCRYPT_SHA256_STATE;
pub type PSYMCRYPT_SHA256_STATE = *mut _SYMCRYPT_SHA256_STATE;
pub type PCSYMCRYPT_SHA256_STATE = *const SYMCRYPT_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_CHAINING_STATE {
    pub H: [UINT64; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_CHAINING_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA512_CHAINING_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_CHAINING_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA512_CHAINING_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_CHAINING_STATE),
            "::",
            stringify!(H)
        )
    );
}
pub type SYMCRYPT_SHA512_CHAINING_STATE = _SYMCRYPT_SHA512_CHAINING_STATE;
pub type PSYMCRYPT_SHA512_CHAINING_STATE = *mut _SYMCRYPT_SHA512_CHAINING_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA512_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA512_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA512_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA512_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA512_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA512_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA512_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA512_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_SHA512_STATE = _SYMCRYPT_SHA512_STATE;
pub type PSYMCRYPT_SHA512_STATE = *mut _SYMCRYPT_SHA512_STATE;
pub type PCSYMCRYPT_SHA512_STATE = *const SYMCRYPT_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SHA384_STATE {
    pub bytesInBuffer: UINT32,
    pub magic: SIZE_T,
    pub dataLengthL: UINT64,
    pub dataLengthH: UINT64,
    pub buffer: [BYTE; 128usize],
    pub chain: SYMCRYPT_SHA512_CHAINING_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SHA384_STATE>(),
        224usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthL)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLengthH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(dataLengthH)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SHA384_STATE),
            "::",
            stringify!(chain)
        )
    );
}
pub type SYMCRYPT_SHA384_STATE = _SYMCRYPT_SHA384_STATE;
pub type PSYMCRYPT_SHA384_STATE = *mut _SYMCRYPT_SHA384_STATE;
pub type PCSYMCRYPT_SHA384_STATE = *const SYMCRYPT_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_KECCAK_STATE {
    pub inputBlockSize: UINT32,
    pub stateIndex: UINT32,
    pub __bindgen_padding_0: u64,
    pub state: [UINT64; 25usize],
    pub magic: SIZE_T,
    pub paddingValue: UINT8,
    pub squeezeMode: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_KECCAK_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_KECCAK_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_KECCAK_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_KECCAK_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_KECCAK_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_KECCAK_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(inputBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paddingValue) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(paddingValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).squeezeMode) as usize - ptr as usize },
        225usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_KECCAK_STATE),
            "::",
            stringify!(squeezeMode)
        )
    );
}
pub type SYMCRYPT_KECCAK_STATE = _SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KECCAK_STATE = *mut _SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KECCAK_STATE = *const SYMCRYPT_KECCAK_STATE;
pub type SYMCRYPT_SHA3_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHA3_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHA3_STATE = *const SYMCRYPT_SHA3_STATE;
pub type SYMCRYPT_SHA3_256_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHA3_256_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHA3_256_STATE = *const SYMCRYPT_SHA3_256_STATE;
pub type SYMCRYPT_SHA3_384_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHA3_384_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHA3_384_STATE = *const SYMCRYPT_SHA3_384_STATE;
pub type SYMCRYPT_SHA3_512_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHA3_512_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHA3_512_STATE = *const SYMCRYPT_SHA3_512_STATE;
pub type SYMCRYPT_SHAKE128_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHAKE128_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHAKE128_STATE = *const SYMCRYPT_SHAKE128_STATE;
pub type SYMCRYPT_SHAKE256_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_SHAKE256_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_SHAKE256_STATE = *const SYMCRYPT_SHAKE256_STATE;
pub type SYMCRYPT_CSHAKE128_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_CSHAKE128_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_CSHAKE128_STATE = *const SYMCRYPT_CSHAKE128_STATE;
pub type SYMCRYPT_CSHAKE256_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_CSHAKE256_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_CSHAKE256_STATE = *const SYMCRYPT_CSHAKE256_STATE;
pub type SYMCRYPT_KMAC128_EXPANDED_KEY = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KMAC128_EXPANDED_KEY = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KMAC128_EXPANDED_KEY = *const SYMCRYPT_KMAC128_EXPANDED_KEY;
pub type SYMCRYPT_KMAC128_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KMAC128_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KMAC128_STATE = *const SYMCRYPT_KMAC128_STATE;
pub type SYMCRYPT_KMAC256_EXPANDED_KEY = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KMAC256_EXPANDED_KEY = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KMAC256_EXPANDED_KEY = *const SYMCRYPT_KMAC256_EXPANDED_KEY;
pub type SYMCRYPT_KMAC256_STATE = SYMCRYPT_KECCAK_STATE;
pub type PSYMCRYPT_KMAC256_STATE = *mut SYMCRYPT_KECCAK_STATE;
pub type PCSYMCRYPT_KMAC256_STATE = *const SYMCRYPT_KMAC256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_HASH_STATE {
    pub md2State: SYMCRYPT_MD2_STATE,
    pub md4State: SYMCRYPT_MD4_STATE,
    pub md5State: SYMCRYPT_MD5_STATE,
    pub sha1State: SYMCRYPT_SHA1_STATE,
    pub sha256State: SYMCRYPT_SHA256_STATE,
    pub sha384State: SYMCRYPT_SHA384_STATE,
    pub sha512State: SYMCRYPT_SHA512_STATE,
    pub sha3_256State: SYMCRYPT_SHA3_256_STATE,
    pub sha3_384State: SYMCRYPT_SHA3_384_STATE,
    pub sha3_512State: SYMCRYPT_SHA3_512_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HASH_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HASH_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md2State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md2State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md4State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md4State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(md5State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha1State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha256State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha384State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha512State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_256State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_256State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_384State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_384State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha3_512State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH_STATE),
            "::",
            stringify!(sha3_512State)
        )
    );
}
pub type SYMCRYPT_HASH_STATE = _SYMCRYPT_HASH_STATE;
pub type PSYMCRYPT_HASH_STATE = *mut _SYMCRYPT_HASH_STATE;
pub type PCSYMCRYPT_HASH_STATE = *const SYMCRYPT_HASH_STATE;
pub type SYMCRYPT_HASH = _SYMCRYPT_HASH;
pub type PSYMCRYPT_HASH = *mut _SYMCRYPT_HASH;
pub type PCSYMCRYPT_HASH = *const SYMCRYPT_HASH;
pub type SYMCRYPT_PARALLEL_HASH = _SYMCRYPT_PARALLEL_HASH;
pub type PSYMCRYPT_PARALLEL_HASH = *mut _SYMCRYPT_PARALLEL_HASH;
pub type PCSYMCRYPT_PARALLEL_HASH = *const SYMCRYPT_PARALLEL_HASH;
pub type PSYMCRYPT_HASH_INIT_FUNC = ::std::option::Option<unsafe extern "C" fn(pState: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_HASH_RESULT_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
pub type PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC = ::std::option::Option<
    unsafe extern "C" fn(pChain: PVOID, pbData: PCBYTE, cbData: SIZE_T, pcbRemaining: *mut SIZE_T),
>;
pub type PSYMCRYPT_HASH_STATE_COPY_FUNC =
    ::std::option::Option<unsafe extern "C" fn(pStateSrc: PCVOID, pStateDst: PVOID)>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HASH {
    pub initFunc: PSYMCRYPT_HASH_INIT_FUNC,
    pub appendFunc: PSYMCRYPT_HASH_APPEND_FUNC,
    pub resultFunc: PSYMCRYPT_HASH_RESULT_FUNC,
    pub appendBlockFunc: PSYMCRYPT_HASH_APPEND_BLOCKS_FUNC,
    pub stateCopyFunc: PSYMCRYPT_HASH_STATE_COPY_FUNC,
    pub stateSize: UINT32,
    pub resultSize: UINT32,
    pub inputBlockSize: UINT32,
    pub chainOffset: UINT32,
    pub chainSize: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HASH> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HASH>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HASH>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendBlockFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(appendBlockFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateCopyFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateCopyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputBlockSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(inputBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainOffset) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainSize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HASH),
            "::",
            stringify!(chainSize)
        )
    );
}
pub const _SYMCRYPT_HASH_OPERATION_TYPE_SYMCRYPT_HASH_OPERATION_APPEND:
    _SYMCRYPT_HASH_OPERATION_TYPE = 1;
pub const _SYMCRYPT_HASH_OPERATION_TYPE_SYMCRYPT_HASH_OPERATION_RESULT:
    _SYMCRYPT_HASH_OPERATION_TYPE = 2;
pub type _SYMCRYPT_HASH_OPERATION_TYPE = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_HASH_OPERATION_TYPE as SYMCRYPT_HASH_OPERATION_TYPE;
pub type SYMCRYPT_PARALLEL_HASH_OPERATION = _SYMCRYPT_PARALLEL_HASH_OPERATION;
pub type PSYMCRYPT_PARALLEL_HASH_OPERATION = *mut _SYMCRYPT_PARALLEL_HASH_OPERATION;
pub type PCSYMRYPT_PARALLEL_HASH_OPERATION = *const SYMCRYPT_PARALLEL_HASH_OPERATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_PARALLEL_HASH_OPERATION {
    pub iHash: SIZE_T,
    pub hashOperation: SYMCRYPT_HASH_OPERATION_TYPE,
    pub pbBuffer: PBYTE,
    pub cbBuffer: SIZE_T,
    pub next: PSYMCRYPT_PARALLEL_HASH_OPERATION,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_PARALLEL_HASH_OPERATION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_PARALLEL_HASH_OPERATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_PARALLEL_HASH_OPERATION>(),
        40usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_PARALLEL_HASH_OPERATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION),
            "::",
            stringify!(iHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashOperation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION),
            "::",
            stringify!(hashOperation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbBuffer) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION),
            "::",
            stringify!(pbBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbBuffer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION),
            "::",
            stringify!(cbBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_OPERATION),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION {
    _unused: [u8; 0],
}
pub type SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION = _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION;
pub type PSYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION = *mut _SYMCRYPT_PARALLEL_HASH_SCRATCH_OPERATION;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE {
    pub hashState: PVOID,
    pub processingState: BYTE,
    pub bytesAlreadyProcessed: BYTE,
    pub bytes: UINT64,
    pub next: PSYMCRYPT_PARALLEL_HASH_OPERATION,
    pub pbData: PCBYTE,
    pub cbData: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(hashState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).processingState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(processingState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesAlreadyProcessed) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(bytesAlreadyProcessed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbData) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(pbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE),
            "::",
            stringify!(cbData)
        )
    );
}
pub type SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE = _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE;
pub type PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE = *mut _SYMCRYPT_PARALLEL_HASH_SCRATCH_STATE;
pub type PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pParHash: PCSYMCRYPT_PARALLEL_HASH,
        pState: PSYMCRYPT_COMMON_HASH_STATE,
        pScratch: PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE,
        pRes: *mut BOOLEAN,
    ) -> BOOLEAN,
>;
pub type PSYMCRYPT_PARALLEL_HASH_RESULT_DONE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pParHash: PCSYMCRYPT_PARALLEL_HASH,
        pState: PSYMCRYPT_COMMON_HASH_STATE,
        pOp: PCSYMRYPT_PARALLEL_HASH_OPERATION,
    ),
>;
pub type PSYMCRYPT_PARALLEL_APPEND_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pWork: *mut PSYMCRYPT_PARALLEL_HASH_SCRATCH_STATE,
        nPar: SIZE_T,
        nBytes: SIZE_T,
        pbSimdScratch: PBYTE,
        cbSimdScratch: SIZE_T,
    ),
>;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_PARALLEL_HASH {
    pub pHash: PCSYMCRYPT_HASH,
    pub parScratchFixed: UINT32,
    pub parResult1Func: PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC,
    pub parResult2Func: PSYMCRYPT_PARALLEL_HASH_RESULT_FUNC,
    pub parResultDoneFunc: PSYMCRYPT_PARALLEL_HASH_RESULT_DONE_FUNC,
    pub parAppendFunc: PSYMCRYPT_PARALLEL_APPEND_FUNC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_PARALLEL_HASH() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_PARALLEL_HASH> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_PARALLEL_HASH>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_PARALLEL_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_PARALLEL_HASH>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_PARALLEL_HASH))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(pHash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parScratchFixed) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(parScratchFixed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parResult1Func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(parResult1Func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parResult2Func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(parResult2Func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parResultDoneFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(parResultDoneFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parAppendFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PARALLEL_HASH),
            "::",
            stringify!(parAppendFunc)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_EXPANDED_KEY {
    pub innerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub outerState: SYMCRYPT_MD5_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_MD5_EXPANDED_KEY = _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY = *const SYMCRYPT_HMAC_MD5_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_MD5_STATE {
    pub hash: SYMCRYPT_MD5_STATE,
    pub pKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_MD5_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_MD5_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_MD5_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_MD5_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_MD5_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_MD5_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_MD5_STATE = _SYMCRYPT_HMAC_MD5_STATE;
pub type PSYMCRYPT_HMAC_MD5_STATE = *mut _SYMCRYPT_HMAC_MD5_STATE;
pub type PCSYMCRYPT_HMAC_MD5_STATE = *const SYMCRYPT_HMAC_MD5_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA1_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA1_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA1_STATE {
    pub hash: SYMCRYPT_SHA1_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA1_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA1_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA1_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA1_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA1_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA1_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA1_STATE = _SYMCRYPT_HMAC_SHA1_STATE;
pub type PSYMCRYPT_HMAC_SHA1_STATE = *mut _SYMCRYPT_HMAC_SHA1_STATE;
pub type PCSYMCRYPT_HMAC_SHA1_STATE = *const SYMCRYPT_HMAC_SHA1_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA256_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        80usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA256_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA256_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA256_STATE {
    pub hash: SYMCRYPT_SHA256_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA256_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA256_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA256_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA256_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA256_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA256_STATE = _SYMCRYPT_HMAC_SHA256_STATE;
pub type PSYMCRYPT_HMAC_SHA256_STATE = *mut _SYMCRYPT_HMAC_SHA256_STATE;
pub type PCSYMCRYPT_HMAC_SHA256_STATE = *const SYMCRYPT_HMAC_SHA256_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA384_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA384_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA384_STATE {
    pub hash: SYMCRYPT_SHA384_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA384_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA384_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA384_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA384_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA384_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA384_STATE = _SYMCRYPT_HMAC_SHA384_STATE;
pub type PSYMCRYPT_HMAC_SHA384_STATE = *mut _SYMCRYPT_HMAC_SHA384_STATE;
pub type PCSYMCRYPT_HMAC_SHA384_STATE = *const SYMCRYPT_HMAC_SHA384_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY {
    pub innerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub outerState: SYMCRYPT_SHA512_CHAINING_STATE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).innerState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(innerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerState) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(outerState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA512_EXPANDED_KEY = _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *mut _SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
pub type PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY = *const SYMCRYPT_HMAC_SHA512_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_HMAC_SHA512_STATE {
    pub hash: SYMCRYPT_SHA512_STATE,
    pub pKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HMAC_SHA512_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HMAC_SHA512_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HMAC_SHA512_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HMAC_SHA512_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HMAC_SHA512_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(hash)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HMAC_SHA512_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_HMAC_SHA512_STATE = _SYMCRYPT_HMAC_SHA512_STATE;
pub type PSYMCRYPT_HMAC_SHA512_STATE = *mut _SYMCRYPT_HMAC_SHA512_STATE;
pub type PCSYMCRYPT_HMAC_SHA512_STATE = *const SYMCRYPT_HMAC_SHA512_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_EXPANDED_KEY {
    pub RoundKey: [[[BYTE; 4usize]; 4usize]; 29usize],
    pub lastEncRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub lastDecRoundKey: *mut [[BYTE; 4usize]; 4usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        496usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RoundKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(RoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastEncRoundKey) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastEncRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastDecRoundKey) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(lastDecRoundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_AES_EXPANDED_KEY = _SYMCRYPT_AES_EXPANDED_KEY;
pub type PSYMCRYPT_AES_EXPANDED_KEY = *mut _SYMCRYPT_AES_EXPANDED_KEY;
pub type PCSYMCRYPT_AES_EXPANDED_KEY = *const SYMCRYPT_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_CMAC_EXPANDED_KEY {
    pub aesKey: SYMCRYPT_AES_EXPANDED_KEY,
    pub K1: [BYTE; 16usize],
    pub K2: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_CMAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_CMAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_CMAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aesKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(aesKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K1) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K2) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(K2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_AES_CMAC_EXPANDED_KEY = _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
pub type PSYMCRYPT_AES_CMAC_EXPANDED_KEY = *mut _SYMCRYPT_AES_CMAC_EXPANDED_KEY;
pub type PCSYMCRYPT_AES_CMAC_EXPANDED_KEY = *const SYMCRYPT_AES_CMAC_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_AES_CMAC_STATE {
    pub chain: [BYTE; 16usize],
    pub buf: [BYTE; 16usize],
    pub bytesInBuf: SIZE_T,
    pub pKey: PCSYMCRYPT_AES_CMAC_EXPANDED_KEY,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_AES_CMAC_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_AES_CMAC_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_AES_CMAC_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_AES_CMAC_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_AES_CMAC_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_AES_CMAC_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_STATE),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_STATE),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuf) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_STATE),
            "::",
            stringify!(bytesInBuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_AES_CMAC_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_AES_CMAC_STATE = _SYMCRYPT_AES_CMAC_STATE;
pub type PSYMCRYPT_AES_CMAC_STATE = *mut _SYMCRYPT_AES_CMAC_STATE;
pub type PCSYMCRYPT_AES_CMAC_STATE = *const SYMCRYPT_AES_CMAC_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_POLY1305_STATE {
    pub r: [UINT32; 4usize],
    pub s: [UINT32; 4usize],
    pub a: [UINT32; 5usize],
    pub bytesInBuffer: SIZE_T,
    pub buf: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_POLY1305_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_POLY1305_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_POLY1305_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_POLY1305_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_POLY1305_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_POLY1305_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInBuffer) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(bytesInBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_POLY1305_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_POLY1305_STATE = _SYMCRYPT_POLY1305_STATE;
pub type PSYMCRYPT_POLY1305_STATE = *mut _SYMCRYPT_POLY1305_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_XTS_AES_EXPANDED_KEY {
    pub key1: SYMCRYPT_AES_EXPANDED_KEY,
    pub key2: SYMCRYPT_AES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_XTS_AES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_XTS_AES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_XTS_AES_EXPANDED_KEY>(),
        992usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_XTS_AES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_XTS_AES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_XTS_AES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_XTS_AES_EXPANDED_KEY),
            "::",
            stringify!(key1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key2) as usize - ptr as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_XTS_AES_EXPANDED_KEY),
            "::",
            stringify!(key2)
        )
    );
}
pub type SYMCRYPT_XTS_AES_EXPANDED_KEY = _SYMCRYPT_XTS_AES_EXPANDED_KEY;
pub type PSYMCRYPT_XTS_AES_EXPANDED_KEY = *mut _SYMCRYPT_XTS_AES_EXPANDED_KEY;
pub type PCSYMCRYPT_XTS_AES_EXPANDED_KEY = *const SYMCRYPT_XTS_AES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_STATE {
    pub md5State: SYMCRYPT_HMAC_MD5_STATE,
    pub sha1State: SYMCRYPT_HMAC_SHA1_STATE,
    pub sha256State: SYMCRYPT_HMAC_SHA256_STATE,
    pub sha384State: SYMCRYPT_HMAC_SHA384_STATE,
    pub sha512State: SYMCRYPT_HMAC_SHA512_STATE,
    pub aescmacState: SYMCRYPT_AES_CMAC_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC_STATE>(),
        240usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(md5State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(sha1State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(sha256State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(sha384State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512State) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(sha512State)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aescmacState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_STATE),
            "::",
            stringify!(aescmacState)
        )
    );
}
pub type SYMCRYPT_MAC_STATE = _SYMCRYPT_MAC_STATE;
pub type PSYMCRYPT_MAC_STATE = *mut _SYMCRYPT_MAC_STATE;
pub type PCSYMCRYPT_MAC_STATE = *const SYMCRYPT_MAC_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MAC_EXPANDED_KEY {
    pub md5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub sha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    pub sha256Key: SYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    pub sha384Key: SYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    pub sha512Key: SYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    pub aescmacKey: SYMCRYPT_AES_CMAC_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        544usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).md5Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(md5Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha1Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha1Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha256Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha256Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha384Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha384Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sha512Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(sha512Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aescmacKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC_EXPANDED_KEY),
            "::",
            stringify!(aescmacKey)
        )
    );
}
pub type SYMCRYPT_MAC_EXPANDED_KEY = _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPANDED_KEY = *mut _SYMCRYPT_MAC_EXPANDED_KEY;
pub type PCSYMCRYPT_MAC_EXPANDED_KEY = *const SYMCRYPT_MAC_EXPANDED_KEY;
pub type PSYMCRYPT_MAC_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_MAC_INIT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pExpandedKey: PCVOID)>;
pub type PSYMCRYPT_MAC_APPEND =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbData: PCBYTE, cbData: SIZE_T)>;
pub type PSYMCRYPT_MAC_RESULT =
    ::std::option::Option<unsafe extern "C" fn(pState: PVOID, pbResult: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MAC {
    pub expandKeyFunc: PSYMCRYPT_MAC_EXPAND_KEY,
    pub initFunc: PSYMCRYPT_MAC_INIT,
    pub appendFunc: PSYMCRYPT_MAC_APPEND,
    pub resultFunc: PSYMCRYPT_MAC_RESULT,
    pub expandedKeySize: SIZE_T,
    pub stateSize: SIZE_T,
    pub resultSize: SIZE_T,
    pub ppHashAlgorithm: *const PCSYMCRYPT_HASH,
    pub outerChainingStateOffset: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MAC() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MAC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MAC>(),
        72usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MAC>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MAC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(initFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).appendFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(appendFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(expandedKeySize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stateSize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(stateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).resultSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(resultSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ppHashAlgorithm) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(ppHashAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outerChainingStateOffset) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MAC),
            "::",
            stringify!(outerChainingStateOffset)
        )
    );
}
pub type SYMCRYPT_MAC = _SYMCRYPT_MAC;
pub type PSYMCRYPT_MAC = *mut _SYMCRYPT_MAC;
pub type PCSYMCRYPT_MAC = *const SYMCRYPT_MAC;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_3DES_EXPANDED_KEY {
    pub roundKey: [[[UINT32; 2usize]; 16usize]; 3usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_3DES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_3DES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_3DES_EXPANDED_KEY>(),
        400usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_3DES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_3DES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_3DES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).roundKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_3DES_EXPANDED_KEY),
            "::",
            stringify!(roundKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_3DES_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_3DES_EXPANDED_KEY = _SYMCRYPT_3DES_EXPANDED_KEY;
pub type PSYMCRYPT_3DES_EXPANDED_KEY = *mut _SYMCRYPT_3DES_EXPANDED_KEY;
pub type PCSYMCRYPT_3DES_EXPANDED_KEY = *const SYMCRYPT_3DES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_DES_EXPANDED_KEY {
    pub threeDes: SYMCRYPT_3DES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DES_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DES_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DES_EXPANDED_KEY>(),
        400usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DES_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DES_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DES_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threeDes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DES_EXPANDED_KEY),
            "::",
            stringify!(threeDes)
        )
    );
}
pub type SYMCRYPT_DES_EXPANDED_KEY = _SYMCRYPT_DES_EXPANDED_KEY;
pub type PSYMCRYPT_DES_EXPANDED_KEY = *mut _SYMCRYPT_DES_EXPANDED_KEY;
pub type PCSYMCRYPT_DES_EXPANDED_KEY = *const SYMCRYPT_DES_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_DESX_EXPANDED_KEY {
    pub desKey: SYMCRYPT_DES_EXPANDED_KEY,
    pub inputWhitening: [BYTE; 8usize],
    pub outputWhitening: [BYTE; 8usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DESX_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DESX_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DESX_EXPANDED_KEY>(),
        416usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DESX_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DESX_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DESX_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).desKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DESX_EXPANDED_KEY),
            "::",
            stringify!(desKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inputWhitening) as usize - ptr as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DESX_EXPANDED_KEY),
            "::",
            stringify!(inputWhitening)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outputWhitening) as usize - ptr as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DESX_EXPANDED_KEY),
            "::",
            stringify!(outputWhitening)
        )
    );
}
pub type SYMCRYPT_DESX_EXPANDED_KEY = _SYMCRYPT_DESX_EXPANDED_KEY;
pub type PSYMCRYPT_DESX_EXPANDED_KEY = *mut _SYMCRYPT_DESX_EXPANDED_KEY;
pub type PCSYMCRYPT_DESX_EXPANDED_KEY = *const SYMCRYPT_DESX_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RC2_EXPANDED_KEY {
    pub K: [UINT16; 64usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RC2_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RC2_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RC2_EXPANDED_KEY>(),
        144usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RC2_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RC2_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RC2_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).K) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC2_EXPANDED_KEY),
            "::",
            stringify!(K)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC2_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_RC2_EXPANDED_KEY = _SYMCRYPT_RC2_EXPANDED_KEY;
pub type PSYMCRYPT_RC2_EXPANDED_KEY = *mut _SYMCRYPT_RC2_EXPANDED_KEY;
pub type PCSYMCRYPT_RC2_EXPANDED_KEY = *const SYMCRYPT_RC2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_CCM_STATE {
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub pExpandedKey: PCVOID,
    pub cbData: UINT64,
    pub cbTag: SIZE_T,
    pub cbNonce: SIZE_T,
    pub cbCounter: SIZE_T,
    pub bytesProcessed: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_CCM_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_CCM_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_CCM_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_CCM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_CCM_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_CCM_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockCipher) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(pBlockCipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pExpandedKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(pExpandedKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(cbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(cbTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbNonce) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(cbNonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbCounter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(cbCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesProcessed) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(bytesProcessed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInMacBlock) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(bytesInMacBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counterBlock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(counterBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macBlock) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(macBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystreamBlock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(keystreamBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CCM_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_CCM_STATE = _SYMCRYPT_CCM_STATE;
pub type PSYMCRYPT_CCM_STATE = *mut _SYMCRYPT_CCM_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS {
    pub aes: SYMCRYPT_AES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        496usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS),
            "::",
            stringify!(aes)
        )
    );
}
pub type SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS = _SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_GF128_ELEMENT {
    pub ull: [UINT64; 2usize],
    pub m128i: __m128i,
    pub ul: [UINT32; 4usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GF128_ELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GF128_ELEMENT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GF128_ELEMENT>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GF128_ELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ull) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ull)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m128i) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(m128i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ul) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GF128_ELEMENT),
            "::",
            stringify!(ul)
        )
    );
}
pub type SYMCRYPT_GF128_ELEMENT = _SYMCRYPT_GF128_ELEMENT;
pub type PSYMCRYPT_GF128_ELEMENT = *mut _SYMCRYPT_GF128_ELEMENT;
pub type PCSYMCRYPT_GF128_ELEMENT = *const SYMCRYPT_GF128_ELEMENT;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GHASH_EXPANDED_KEY {
    pub table: [SYMCRYPT_GF128_ELEMENT; 128usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GHASH_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GHASH_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        2048usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GHASH_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GHASH_EXPANDED_KEY),
            "::",
            stringify!(table)
        )
    );
}
pub type SYMCRYPT_GHASH_EXPANDED_KEY = _SYMCRYPT_GHASH_EXPANDED_KEY;
pub type PSYMCRYPT_GHASH_EXPANDED_KEY = *mut _SYMCRYPT_GHASH_EXPANDED_KEY;
pub type PCSYMCRYPT_GHASH_EXPANDED_KEY = *const SYMCRYPT_GHASH_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_EXPANDED_KEY {
    pub ghashKey: SYMCRYPT_GHASH_EXPANDED_KEY,
    pub pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
    pub __bindgen_padding_0: u64,
    pub blockcipherKey: SYMCRYPT_GCM_SUPPORTED_BLOCKCIPHER_KEYS,
    pub cbKey: SIZE_T,
    pub abKey: [BYTE; 32usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        2608usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(ghashKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pBlockCipher) as usize - ptr as usize },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(pBlockCipher)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockcipherKey) as usize - ptr as usize },
        2064usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(blockcipherKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbKey) as usize - ptr as usize },
        2560usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(cbKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abKey) as usize - ptr as usize },
        2568usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(abKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        2600usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_EXPANDED_KEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_GCM_EXPANDED_KEY = _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PSYMCRYPT_GCM_EXPANDED_KEY = *mut _SYMCRYPT_GCM_EXPANDED_KEY;
pub type PCSYMCRYPT_GCM_EXPANDED_KEY = *const SYMCRYPT_GCM_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_GCM_STATE {
    pub pKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
    pub cbData: UINT64,
    pub cbAuthData: UINT64,
    pub bytesInMacBlock: SIZE_T,
    pub ghashState: SYMCRYPT_GF128_ELEMENT,
    pub counterBlock: [BYTE; 16usize],
    pub macBlock: [BYTE; 16usize],
    pub keystreamBlock: [BYTE; 16usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_GCM_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_GCM_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_GCM_STATE>(),
        112usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_GCM_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_GCM_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(pKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAuthData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(cbAuthData)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bytesInMacBlock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(bytesInMacBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ghashState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(ghashState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counterBlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(counterBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macBlock) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(macBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystreamBlock) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(keystreamBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_GCM_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_GCM_STATE = _SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_GCM_STATE = *mut _SYMCRYPT_GCM_STATE;
pub type PCSYMCRYPT_GCM_STATE = *const SYMCRYPT_GCM_STATE;
pub type PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PVOID, pbKey: PCBYTE, cbKey: SIZE_T) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT =
    ::std::option::Option<unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE)>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB = ::std::option::Option<
    unsafe extern "C" fn(pExpandedKey: PCVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
pub type PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_MAC_MODE = ::std::option::Option<
    unsafe extern "C" fn(
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        cbData: SIZE_T,
    ),
>;
pub type PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE = ::std::option::Option<
    unsafe extern "C" fn(pState: PVOID, pbSrc: PCBYTE, pbDst: PBYTE, cbData: SIZE_T),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_BLOCKCIPHER {
    pub expandKeyFunc: PSYMCRYPT_BLOCKCIPHER_EXPAND_KEY,
    pub encryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub decryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT,
    pub ecbEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub ecbDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_ECB,
    pub cbcEncryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcDecryptFunc: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub cbcMacFunc: PSYMCRYPT_BLOCKCIPHER_MAC_MODE,
    pub ctrMsb64Func: PSYMCRYPT_BLOCKCIPHER_CRYPT_MODE,
    pub gcmEncryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub gcmDecryptPartFunc: PSYMCRYPT_BLOCKCIPHER_AEADPART_MODE,
    pub blockSize: SIZE_T,
    pub expandedKeySize: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_BLOCKCIPHER() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_BLOCKCIPHER> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_BLOCKCIPHER>(),
        104usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_BLOCKCIPHER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_BLOCKCIPHER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandKeyFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandKeyFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encryptFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(encryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decryptFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(decryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbEncryptFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ecbDecryptFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ecbDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcEncryptFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcEncryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcDecryptFunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcDecryptFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbcMacFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(cbcMacFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ctrMsb64Func) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(ctrMsb64Func)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmEncryptPartFunc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmEncryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gcmDecryptPartFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(gcmDecryptPartFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSize) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(blockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).expandedKeySize) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_BLOCKCIPHER),
            "::",
            stringify!(expandedKeySize)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SESSION_REPLAY_STATE {
    pub replayMask: UINT64,
    pub messageNumber: UINT64,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SESSION_REPLAY_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SESSION_REPLAY_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SESSION_REPLAY_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SESSION_REPLAY_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SESSION_REPLAY_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SESSION_REPLAY_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayMask) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION_REPLAY_STATE),
            "::",
            stringify!(replayMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).messageNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION_REPLAY_STATE),
            "::",
            stringify!(messageNumber)
        )
    );
}
pub type SYMCRYPT_SESSION_REPLAY_STATE = _SYMCRYPT_SESSION_REPLAY_STATE;
pub type PSYMCRYPT_SESSION_REPLAY_STATE = *mut _SYMCRYPT_SESSION_REPLAY_STATE;
pub type PCSYMCRYPT_SESSION_REPLAY_STATE = *const SYMCRYPT_SESSION_REPLAY_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SESSION {
    pub replayState: SYMCRYPT_SESSION_REPLAY_STATE,
    pub senderId: UINT32,
    pub flags: UINT32,
    pub pMutex: PVOID,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SESSION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SESSION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SESSION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SESSION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SESSION>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SESSION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).replayState) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION),
            "::",
            stringify!(replayState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).senderId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION),
            "::",
            stringify!(senderId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pMutex) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SESSION),
            "::",
            stringify!(pMutex)
        )
    );
}
pub type SYMCRYPT_SESSION = _SYMCRYPT_SESSION;
pub type PSYMCRYPT_SESSION = *mut _SYMCRYPT_SESSION;
pub type SYMCRYPT_RC4_S_TYPE = BYTE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RC4_STATE {
    pub S: [SYMCRYPT_RC4_S_TYPE; 256usize],
    pub i: BYTE,
    pub j: BYTE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RC4_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RC4_STATE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RC4_STATE>(),
        272usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RC4_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RC4_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RC4_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).S) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC4_STATE),
            "::",
            stringify!(S)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC4_STATE),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        257usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC4_STATE),
            "::",
            stringify!(j)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RC4_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_RC4_STATE = _SYMCRYPT_RC4_STATE;
pub type PSYMCRYPT_RC4_STATE = *mut _SYMCRYPT_RC4_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_CHACHA20_STATE {
    pub key: [UINT32; 8usize],
    pub nonce: [UINT32; 3usize],
    pub offset: UINT64,
    pub keystreamBufferValid: BOOLEAN,
    pub keystream: [BYTE; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_CHACHA20_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_CHACHA20_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_CHACHA20_STATE>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_CHACHA20_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_CHACHA20_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_CHACHA20_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CHACHA20_STATE),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nonce) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CHACHA20_STATE),
            "::",
            stringify!(nonce)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CHACHA20_STATE),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystreamBufferValid) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CHACHA20_STATE),
            "::",
            stringify!(keystreamBufferValid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keystream) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_CHACHA20_STATE),
            "::",
            stringify!(keystream)
        )
    );
}
pub type SYMCRYPT_CHACHA20_STATE = _SYMCRYPT_CHACHA20_STATE;
pub type PSYMCRYPT_CHACHA20_STATE = *mut _SYMCRYPT_CHACHA20_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RNG_AES_STATE {
    pub keyAndV: [BYTE; 48usize],
    pub previousBlock: [BYTE; 16usize],
    pub requestCounter: UINT64,
    pub fips140_2Check: BOOLEAN,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RNG_AES_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RNG_AES_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RNG_AES_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RNG_AES_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RNG_AES_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RNG_AES_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keyAndV) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_STATE),
            "::",
            stringify!(keyAndV)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).previousBlock) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_STATE),
            "::",
            stringify!(previousBlock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).requestCounter) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_STATE),
            "::",
            stringify!(requestCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fips140_2Check) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_STATE),
            "::",
            stringify!(fips140_2Check)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_RNG_AES_STATE = _SYMCRYPT_RNG_AES_STATE;
pub type PSYMCRYPT_RNG_AES_STATE = *mut _SYMCRYPT_RNG_AES_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RNG_AES_FIPS140_2_STATE {
    pub rng: SYMCRYPT_RNG_AES_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RNG_AES_FIPS140_2_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RNG_AES_FIPS140_2_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RNG_AES_FIPS140_2_STATE>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RNG_AES_FIPS140_2_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RNG_AES_FIPS140_2_STATE>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_RNG_AES_FIPS140_2_STATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rng) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RNG_AES_FIPS140_2_STATE),
            "::",
            stringify!(rng)
        )
    );
}
pub type SYMCRYPT_RNG_AES_FIPS140_2_STATE = _SYMCRYPT_RNG_AES_FIPS140_2_STATE;
pub type PSYMCRYPT_RNG_AES_FIPS140_2_STATE = *mut _SYMCRYPT_RNG_AES_FIPS140_2_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MARVIN32_EXPANDED_SEED {
    pub s: [UINT32; 2usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MARVIN32_EXPANDED_SEED() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MARVIN32_EXPANDED_SEED> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MARVIN32_EXPANDED_SEED>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MARVIN32_EXPANDED_SEED))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MARVIN32_EXPANDED_SEED>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MARVIN32_EXPANDED_SEED)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_EXPANDED_SEED),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_EXPANDED_SEED),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_MARVIN32_EXPANDED_SEED = _SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PSYMCRYPT_MARVIN32_EXPANDED_SEED = *mut _SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PCSYMCRYPT_MARVIN32_EXPANDED_SEED = *const SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type SYMCRYPT_MARVIN32_CHAINING_STATE = SYMCRYPT_MARVIN32_EXPANDED_SEED;
pub type PSYMCRYPT_MARVIN32_CHAINING_STATE = *mut SYMCRYPT_MARVIN32_EXPANDED_SEED;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MARVIN32_STATE {
    pub buffer: [BYTE; 8usize],
    pub __bindgen_padding_0: u64,
    pub chain: SYMCRYPT_MARVIN32_CHAINING_STATE,
    pub pSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
    pub dataLength: UINT32,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MARVIN32_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MARVIN32_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MARVIN32_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MARVIN32_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MARVIN32_STATE>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MARVIN32_STATE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_STATE),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chain) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_STATE),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pSeed) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_STATE),
            "::",
            stringify!(pSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dataLength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_STATE),
            "::",
            stringify!(dataLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MARVIN32_STATE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_MARVIN32_STATE = _SYMCRYPT_MARVIN32_STATE;
pub type PSYMCRYPT_MARVIN32_STATE = *mut _SYMCRYPT_MARVIN32_STATE;
pub type PCSYMCRYPT_MARVIN32_STATE = *const SYMCRYPT_MARVIN32_STATE;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_PBKDF2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_PBKDF2_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_PBKDF2_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_PBKDF2_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_PBKDF2_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_PBKDF2_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_PBKDF2_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PBKDF2_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_PBKDF2_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
pub type SYMCRYPT_PBKDF2_EXPANDED_KEY = _SYMCRYPT_PBKDF2_EXPANDED_KEY;
pub type PSYMCRYPT_PBKDF2_EXPANDED_KEY = *mut _SYMCRYPT_PBKDF2_EXPANDED_KEY;
pub type PCSYMCRYPT_PBKDF2_EXPANDED_KEY = *const SYMCRYPT_PBKDF2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_SP800_108_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SP800_108_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SP800_108_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SP800_108_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SP800_108_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SP800_108_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_SP800_108_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SP800_108_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SP800_108_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
pub type SYMCRYPT_SP800_108_EXPANDED_KEY = _SYMCRYPT_SP800_108_EXPANDED_KEY;
pub type PSYMCRYPT_SP800_108_EXPANDED_KEY = *mut _SYMCRYPT_SP800_108_EXPANDED_KEY;
pub type PCSYMCRYPT_SP800_108_EXPANDED_KEY = *const SYMCRYPT_SP800_108_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY {
    pub macMd5Key: SYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    pub macSha1Key: SYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TLSPRF1_1_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macMd5Key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY),
            "::",
            stringify!(macMd5Key)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macSha1Key) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_1_EXPANDED_KEY),
            "::",
            stringify!(macSha1Key)
        )
    );
}
pub type SYMCRYPT_TLSPRF1_1_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_1_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_1_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_1_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TLSPRF1_2_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TLSPRF1_2_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
pub type SYMCRYPT_TLSPRF1_2_EXPANDED_KEY = _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *mut _SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
pub type PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY = *const SYMCRYPT_TLSPRF1_2_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_SSHKDF_EXPANDED_KEY {
    pub pHashFunc: PCSYMCRYPT_HASH,
    pub __bindgen_padding_0: u64,
    pub hashState: SYMCRYPT_HASH_STATE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SSHKDF_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SSHKDF_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SSHKDF_EXPANDED_KEY>(),
        256usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SSHKDF_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SSHKDF_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SSHKDF_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHashFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SSHKDF_EXPANDED_KEY),
            "::",
            stringify!(pHashFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashState) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SSHKDF_EXPANDED_KEY),
            "::",
            stringify!(hashState)
        )
    );
}
pub type SYMCRYPT_SSHKDF_EXPANDED_KEY = _SYMCRYPT_SSHKDF_EXPANDED_KEY;
pub type PSYMCRYPT_SSHKDF_EXPANDED_KEY = *mut _SYMCRYPT_SSHKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_SSHKDF_EXPANDED_KEY = *const SYMCRYPT_SSHKDF_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_SRTPKDF_EXPANDED_KEY {
    pub aesExpandedKey: SYMCRYPT_AES_EXPANDED_KEY,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_SRTPKDF_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_SRTPKDF_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_SRTPKDF_EXPANDED_KEY>(),
        496usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_SRTPKDF_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_SRTPKDF_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_SRTPKDF_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).aesExpandedKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_SRTPKDF_EXPANDED_KEY),
            "::",
            stringify!(aesExpandedKey)
        )
    );
}
pub type SYMCRYPT_SRTPKDF_EXPANDED_KEY = _SYMCRYPT_SRTPKDF_EXPANDED_KEY;
pub type PSYMCRYPT_SRTPKDF_EXPANDED_KEY = *mut _SYMCRYPT_SRTPKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_SRTPKDF_EXPANDED_KEY = *const SYMCRYPT_SRTPKDF_EXPANDED_KEY;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_HKDF_EXPANDED_KEY {
    pub macKey: SYMCRYPT_MAC_EXPANDED_KEY,
    pub macAlg: PCSYMCRYPT_MAC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_HKDF_EXPANDED_KEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_HKDF_EXPANDED_KEY> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        560usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_HKDF_EXPANDED_KEY>(),
        16usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlg) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_HKDF_EXPANDED_KEY),
            "::",
            stringify!(macAlg)
        )
    );
}
pub type SYMCRYPT_HKDF_EXPANDED_KEY = _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PSYMCRYPT_HKDF_EXPANDED_KEY = *mut _SYMCRYPT_HKDF_EXPANDED_KEY;
pub type PCSYMCRYPT_HKDF_EXPANDED_KEY = *const SYMCRYPT_HKDF_EXPANDED_KEY;
pub type SYMCRYPT_INT = _SYMCRYPT_INT;
pub type PSYMCRYPT_INT = *mut SYMCRYPT_INT;
pub type PCSYMCRYPT_INT = *const SYMCRYPT_INT;
pub type SYMCRYPT_DIVISOR = _SYMCRYPT_DIVISOR;
pub type PSYMCRYPT_DIVISOR = *mut SYMCRYPT_DIVISOR;
pub type PCSYMCRYPT_DIVISOR = *const SYMCRYPT_DIVISOR;
pub type SYMCRYPT_MODULUS = _SYMCRYPT_MODULUS;
pub type PSYMCRYPT_MODULUS = *mut SYMCRYPT_MODULUS;
pub type PCSYMCRYPT_MODULUS = *const SYMCRYPT_MODULUS;
pub type SYMCRYPT_MODELEMENT = _SYMCRYPT_MODELEMENT;
pub type PSYMCRYPT_MODELEMENT = *mut SYMCRYPT_MODELEMENT;
pub type PCSYMCRYPT_MODELEMENT = *const SYMCRYPT_MODELEMENT;
pub type SYMCRYPT_ECPOINT = _SYMCRYPT_ECPOINT;
pub type PSYMCRYPT_ECPOINT = *mut SYMCRYPT_ECPOINT;
pub type PCSYMCRYPT_ECPOINT = *const SYMCRYPT_ECPOINT;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_INT {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub magic: SIZE_T,
    pub __bindgen_padding_0: [u32; 2usize],
    pub ti: _SYMCRYPT_INT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_INT__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_INT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_INT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_INT>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_INT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_INT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ti) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_INT),
            "::",
            stringify!(ti)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub nBits: UINT32,
    pub magic: SIZE_T,
    pub td: _SYMCRYPT_DIVISOR__bindgen_ty_1,
    pub Int: SYMCRYPT_INT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_DIVISOR__bindgen_ty_1 {
    pub fdef: _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1 {
    pub W: UINT64,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(W)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fdef) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR__bindgen_ty_1),
            "::",
            stringify!(fdef)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DIVISOR() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DIVISOR> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DIVISOR>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DIVISOR>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DIVISOR))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBits) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(nBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).td) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Int) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DIVISOR),
            "::",
            stringify!(Int)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODULUS {
    pub type_: UINT32,
    pub nDigits: UINT32,
    pub cbSize: UINT32,
    pub flags: UINT32,
    pub cbModElement: UINT32,
    pub magic: SIZE_T,
    pub tm: _SYMCRYPT_MODULUS__bindgen_ty_1,
    pub __bindgen_padding_0: [u64; 2usize],
    pub Divisor: SYMCRYPT_DIVISOR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODULUS__bindgen_ty_1 {
    pub montgomery: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1,
    pub pseudoMersenne: _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1 {
    pub inv64: UINT64,
    pub Rsqr: PCUINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inv64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(inv64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsqr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Rsqr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2 {
    pub k: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(k)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).montgomery) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(montgomery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pseudoMersenne) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS__bindgen_ty_1),
            "::",
            stringify!(pseudoMersenne)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODULUS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODULUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODULUS>(),
        160usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODULUS>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODULUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(nDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(tm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Divisor) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODULUS),
            "::",
            stringify!(Divisor)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_MODELEMENT {
    pub d: _SYMCRYPT_MODELEMENT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_MODELEMENT__bindgen_ty_1 {
    pub uint32: [UINT32; 1usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uint32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT__bindgen_ty_1),
            "::",
            stringify!(uint32)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_MODELEMENT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_MODELEMENT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_MODELEMENT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_MODELEMENT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_MODELEMENT),
            "::",
            stringify!(d)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RSAKEY {
    pub fAlgorithmInfo: UINT32,
    pub cbTotalSize: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub nSetBitsOfModulus: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nDigitsOfModulus: UINT32,
    pub nPubExp: UINT32,
    pub nPrimes: UINT32,
    pub nBitsOfPrimes: [UINT32; 2usize],
    pub nDigitsOfPrimes: [UINT32; 2usize],
    pub nMaxDigitsOfPrimes: UINT32,
    pub au64PubExp: [UINT64; 1usize],
    pub pbPrimes: [PBYTE; 2usize],
    pub pbCrtInverses: [PBYTE; 2usize],
    pub pbPrivExps: [PBYTE; 1usize],
    pub pbCrtPrivExps: [PBYTE; 2usize],
    pub pmModulus: PSYMCRYPT_MODULUS,
    pub pmPrimes: [PSYMCRYPT_MODULUS; 2usize],
    pub peCrtInverses: [PSYMCRYPT_MODELEMENT; 2usize],
    pub piPrivExps: [PSYMCRYPT_INT; 1usize],
    pub piCrtPrivExps: [PSYMCRYPT_INT; 2usize],
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSAKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RSAKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSAKEY>(),
        192usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RSAKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSAKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RSAKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbTotalSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(cbTotalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasPrivateKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(hasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSetBitsOfModulus) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nSetBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfModulus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfModulus) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nDigitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPubExp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nPubExp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfPrimes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nBitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfPrimes) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nDigitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxDigitsOfPrimes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(nMaxDigitsOfPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).au64PubExp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(au64PubExp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbPrimes) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbCrtInverses) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbCrtInverses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbPrivExps) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbCrtPrivExps) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pbCrtPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmModulus) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pmModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmPrimes) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(pmPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peCrtInverses) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(peCrtInverses)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivExps) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(piPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piCrtPrivExps) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(piCrtPrivExps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSAKEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_RSAKEY = _SYMCRYPT_RSAKEY;
pub type PSYMCRYPT_RSAKEY = *mut SYMCRYPT_RSAKEY;
pub type PCSYMCRYPT_RSAKEY = *const SYMCRYPT_RSAKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_TRIALDIVISION_PRIME {
    pub invMod2e64: UINT64,
    pub compareLimit: UINT64,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TRIALDIVISION_PRIME() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TRIALDIVISION_PRIME> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TRIALDIVISION_PRIME>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TRIALDIVISION_PRIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TRIALDIVISION_PRIME>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_TRIALDIVISION_PRIME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).invMod2e64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_PRIME),
            "::",
            stringify!(invMod2e64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compareLimit) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_PRIME),
            "::",
            stringify!(compareLimit)
        )
    );
}
pub type SYMCRYPT_TRIALDIVISION_PRIME = _SYMCRYPT_TRIALDIVISION_PRIME;
pub type PSYMCRYPT_TRIALDIVISION_PRIME = *mut _SYMCRYPT_TRIALDIVISION_PRIME;
pub type PCSYMCRYPT_TRIALDIVISION_PRIME = *const SYMCRYPT_TRIALDIVISION_PRIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_TRIALDIVISION_GROUP {
    pub nPrimes: UINT32,
    pub factor: [UINT32; 9usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TRIALDIVISION_GROUP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TRIALDIVISION_GROUP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TRIALDIVISION_GROUP>(),
        40usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TRIALDIVISION_GROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TRIALDIVISION_GROUP>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_TRIALDIVISION_GROUP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_GROUP),
            "::",
            stringify!(nPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_GROUP),
            "::",
            stringify!(factor)
        )
    );
}
pub type SYMCRYPT_TRIALDIVISION_GROUP = _SYMCRYPT_TRIALDIVISION_GROUP;
pub type PSYMCRYPT_TRIALDIVISION_GROUP = *mut _SYMCRYPT_TRIALDIVISION_GROUP;
pub type PCSYMCRYPT_TRIALDIVISION_GROUP = *const SYMCRYPT_TRIALDIVISION_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_TRIALDIVISION_CONTEXT {
    pub nBytesAlloc: SIZE_T,
    pub maxTrialPrime: UINT32,
    pub pGroupList: PSYMCRYPT_TRIALDIVISION_GROUP,
    pub pPrimeList: PSYMCRYPT_TRIALDIVISION_PRIME,
    pub pPrimes: PUINT32,
    pub Primes3_5_17: [SYMCRYPT_TRIALDIVISION_PRIME; 3usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_TRIALDIVISION_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_TRIALDIVISION_CONTEXT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_TRIALDIVISION_CONTEXT>(),
        88usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_TRIALDIVISION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBytesAlloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(nBytesAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxTrialPrime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(maxTrialPrime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pGroupList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(pGroupList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPrimeList) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(pPrimeList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pPrimes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(pPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Primes3_5_17) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_TRIALDIVISION_CONTEXT),
            "::",
            stringify!(Primes3_5_17)
        )
    );
}
pub type SYMCRYPT_TRIALDIVISION_CONTEXT = _SYMCRYPT_TRIALDIVISION_CONTEXT;
pub type PSYMCRYPT_TRIALDIVISION_CONTEXT = *mut _SYMCRYPT_TRIALDIVISION_CONTEXT;
pub type PCSYMCRYPT_TRIALDIVISION_CONTEXT = *const SYMCRYPT_TRIALDIVISION_CONTEXT;
extern "C" {
    pub fn SymCryptTestTrialdivisionMaxSmallPrime(
        pContext: PCSYMCRYPT_TRIALDIVISION_CONTEXT,
    ) -> UINT32;
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_DLGROUP {
    pub cbTotalSize: UINT32,
    pub fHasPrimeQ: BOOLEAN,
    pub nBitsOfP: UINT32,
    pub cbPrimeP: UINT32,
    pub nDigitsOfP: UINT32,
    pub nMaxBitsOfP: UINT32,
    pub nBitsOfQ: UINT32,
    pub cbPrimeQ: UINT32,
    pub nDigitsOfQ: UINT32,
    pub nMaxBitsOfQ: UINT32,
    pub isSafePrimeGroup: BOOLEAN,
    pub nMinBitsPriv: UINT32,
    pub nDefaultBitsPriv: UINT32,
    pub nBitsOfSeed: UINT32,
    pub cbSeed: UINT32,
    pub eFipsStandard: SYMCRYPT_DLGROUP_FIPS,
    pub pHashAlgorithm: PCSYMCRYPT_HASH,
    pub dwGenCounter: UINT32,
    pub bIndexGenG: BYTE,
    pub pbQ: PBYTE,
    pub pmP: PSYMCRYPT_MODULUS,
    pub pmQ: PSYMCRYPT_MODULUS,
    pub peG: PSYMCRYPT_MODELEMENT,
    pub pbSeed: PBYTE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DLGROUP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DLGROUP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DLGROUP>(),
        128usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DLGROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DLGROUP>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DLGROUP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbTotalSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(cbTotalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHasPrimeQ) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(fHasPrimeQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfP) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nBitsOfP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbPrimeP) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(cbPrimeP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfP) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nDigitsOfP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxBitsOfP) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nMaxBitsOfP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfQ) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nBitsOfQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbPrimeQ) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(cbPrimeQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDigitsOfQ) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nDigitsOfQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMaxBitsOfQ) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nMaxBitsOfQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isSafePrimeGroup) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(isSafePrimeGroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nMinBitsPriv) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nMinBitsPriv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nDefaultBitsPriv) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nDefaultBitsPriv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfSeed) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(nBitsOfSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSeed) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(cbSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eFipsStandard) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(eFipsStandard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pHashAlgorithm) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(pHashAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwGenCounter) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(dwGenCounter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bIndexGenG) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(bIndexGenG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbQ) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(pbQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmP) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(pmP)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pmQ) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(pmQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peG) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(peG)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbSeed) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(pbSeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLGROUP),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_DLGROUP = _SYMCRYPT_DLGROUP;
pub type PSYMCRYPT_DLGROUP = *mut SYMCRYPT_DLGROUP;
pub type PCSYMCRYPT_DLGROUP = *const SYMCRYPT_DLGROUP;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_DLKEY {
    pub fAlgorithmInfo: UINT32,
    pub fHasPrivateKey: BOOLEAN,
    pub fPrivateModQ: BOOLEAN,
    pub nBitsPriv: UINT32,
    pub pDlgroup: PCSYMCRYPT_DLGROUP,
    pub pbPrivate: PBYTE,
    pub pePublicKey: PSYMCRYPT_MODELEMENT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_DLKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_DLKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_DLKEY>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_DLKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_DLKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_DLKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fHasPrivateKey) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(fHasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fPrivateModQ) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(fPrivateModQ)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsPriv) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(nBitsPriv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pDlgroup) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(pDlgroup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbPrivate) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(pbPrivate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pePublicKey) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(pePublicKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivateKey) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(piPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_DLKEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_DLKEY = _SYMCRYPT_DLKEY;
pub type PSYMCRYPT_DLKEY = *mut SYMCRYPT_DLKEY;
pub type PCSYMCRYPT_DLKEY = *const SYMCRYPT_DLKEY;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_INVALID:
    _SYMCRYPT_ECPOINT_COORDINATES = 0;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE:
    _SYMCRYPT_ECPOINT_COORDINATES = 17;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_AFFINE:
    _SYMCRYPT_ECPOINT_COORDINATES = 34;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 51;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_JACOBIAN:
    _SYMCRYPT_ECPOINT_COORDINATES = 67;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_EXTENDED_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 84;
pub const _SYMCRYPT_ECPOINT_COORDINATES_SYMCRYPT_ECPOINT_COORDINATES_SINGLE_PROJECTIVE:
    _SYMCRYPT_ECPOINT_COORDINATES = 98;
pub type _SYMCRYPT_ECPOINT_COORDINATES = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECPOINT_COORDINATES as SYMCRYPT_ECPOINT_COORDINATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_INFO_PRECOMP {
    pub window: UINT32,
    pub nPrecompPoints: UINT32,
    pub nRecodedDigits: UINT32,
    pub poPrecompPoints: [PSYMCRYPT_ECPOINT; 64usize],
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_INFO_PRECOMP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_INFO_PRECOMP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_INFO_PRECOMP>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrecompPoints) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nPrecompPoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRecodedDigits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(nRecodedDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPrecompPoints) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_INFO_PRECOMP),
            "::",
            stringify!(poPrecompPoints)
        )
    );
}
pub type SYMCRYPT_ECURVE_INFO_PRECOMP = _SYMCRYPT_ECURVE_INFO_PRECOMP;
#[repr(C)]
#[repr(align(32))]
#[derive(Copy, Clone)]
pub struct _SYMCRYPT_ECURVE {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub eCoordinates: SYMCRYPT_ECPOINT_COORDINATES,
    pub FModBitsize: UINT32,
    pub FModDigits: UINT32,
    pub FModBytesize: UINT32,
    pub GOrdBitsize: UINT32,
    pub GOrdDigits: UINT32,
    pub GOrdBytesize: UINT32,
    pub cbModElement: UINT32,
    pub cbAlloc: UINT32,
    pub cbScratchCommon: UINT32,
    pub cbScratchScalar: UINT32,
    pub cbScratchScalarMulti: UINT32,
    pub cbScratchGetSetValue: UINT32,
    pub cbScratchEckey: UINT32,
    pub coFactorPower: UINT32,
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
    pub info: _SYMCRYPT_ECURVE__bindgen_ty_1,
    pub FMod: PSYMCRYPT_MODULUS,
    pub GOrd: PSYMCRYPT_MODULUS,
    pub A: PSYMCRYPT_MODELEMENT,
    pub B: PSYMCRYPT_MODELEMENT,
    pub G: PSYMCRYPT_ECPOINT,
    pub H: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYMCRYPT_ECURVE__bindgen_ty_1 {
    pub sw: SYMCRYPT_ECURVE_INFO_PRECOMP,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        528usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE__bindgen_ty_1),
            "::",
            stringify!(sw)
        )
    );
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE>(),
        672usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eCoordinates) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(eCoordinates)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBitsize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModDigits) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FModBytesize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FModBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBitsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBitsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdDigits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdDigits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrdBytesize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrdBytesize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbModElement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbModElement)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbAlloc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchCommon) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchCommon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalar) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchScalarMulti) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchScalarMulti)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchGetSetValue) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchGetSetValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbScratchEckey) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(cbScratchEckey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).coFactorPower) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(coFactorPower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivateKeyDefaultFormat) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(PrivateKeyDefaultFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionNumOfBits) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionNumOfBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionPosition) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionValue) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(HighBitRestrictionValue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FMod) as usize - ptr as usize },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(FMod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GOrd) as usize - ptr as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(GOrd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).A) as usize - ptr as usize },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).B) as usize - ptr as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).G) as usize - ptr as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).H) as usize - ptr as usize },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_ECURVE = _SYMCRYPT_ECURVE;
pub type PSYMCRYPT_ECURVE = *mut SYMCRYPT_ECURVE;
pub type PCSYMCRYPT_ECURVE = *const SYMCRYPT_ECURVE;
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECPOINT {
    pub normalized: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECPOINT>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).normalized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(normalized)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECPOINT),
            "::",
            stringify!(magic)
        )
    );
}
#[repr(C)]
#[repr(align(32))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECKEY {
    pub fAlgorithmInfo: UINT32,
    pub hasPrivateKey: BOOLEAN,
    pub pCurve: PCSYMCRYPT_ECURVE,
    pub poPublicKey: PSYMCRYPT_ECPOINT,
    pub piPrivateKey: PSYMCRYPT_INT,
    pub magic: SIZE_T,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECKEY() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECKEY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECKEY>(),
        64usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECKEY>(),
        32usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECKEY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fAlgorithmInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(fAlgorithmInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hasPrivateKey) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(hasPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPublicKey) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(poPublicKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).piPrivateKey) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(piPrivateKey)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECKEY),
            "::",
            stringify!(magic)
        )
    );
}
pub type SYMCRYPT_ECKEY = _SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECKEY = *mut SYMCRYPT_ECKEY;
pub type PCSYMCRYPT_ECKEY = *const SYMCRYPT_ECKEY;
pub type PSYMCRYPT_ECPOINT_SET_ZERO_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_SET_DISTINGUISHED_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_SET_RANDOM_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        piScalar: PSYMCRYPT_INT,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_ISEQUAL_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc1: PCSYMCRYPT_ECPOINT,
        poSrc2: PCSYMCRYPT_ECPOINT,
        flags: UINT32,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> UINT32,
>;
pub type PSYMCRYPT_ECPOINT_ONCURVE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc: PCSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> UINT32,
>;
pub type PSYMCRYPT_ECPOINT_ISZERO_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc: PCSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> UINT32,
>;
pub type PSYMCRYPT_ECPOINT_ADD_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc1: PCSYMCRYPT_ECPOINT,
        poSrc2: PCSYMCRYPT_ECPOINT,
        poDst: PSYMCRYPT_ECPOINT,
        flags: UINT32,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_ADD_DIFF_NONZERO_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc1: PCSYMCRYPT_ECPOINT,
        poSrc2: PCSYMCRYPT_ECPOINT,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_DOUBLE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc: PCSYMCRYPT_ECPOINT,
        poDst: PSYMCRYPT_ECPOINT,
        flags: UINT32,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_NEGATE_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        poSrc: PSYMCRYPT_ECPOINT,
        mask: UINT32,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ),
>;
pub type PSYMCRYPT_ECPOINT_SCALAR_MUL_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        piScalar: PCSYMCRYPT_INT,
        poSrc: PCSYMCRYPT_ECPOINT,
        flags: UINT32,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> SYMCRYPT_ERROR,
>;
pub type PSYMCRYPT_ECPOINT_MULTI_SCALAR_MUL_FUNC = ::std::option::Option<
    unsafe extern "C" fn(
        pCurve: PCSYMCRYPT_ECURVE,
        piSrcScalarArray: *mut PCSYMCRYPT_INT,
        peSrcEcpointArray: *mut PCSYMCRYPT_ECPOINT,
        nPoints: UINT32,
        flags: UINT32,
        poDst: PSYMCRYPT_ECPOINT,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> SYMCRYPT_ERROR,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_FUNCTIONS {
    pub setZeroFunc: PSYMCRYPT_ECPOINT_SET_ZERO_FUNC,
    pub setDistinguishedFunc: PSYMCRYPT_ECPOINT_SET_DISTINGUISHED_FUNC,
    pub setRandomFunc: PSYMCRYPT_ECPOINT_SET_RANDOM_FUNC,
    pub isEqualFunc: PSYMCRYPT_ECPOINT_ISEQUAL_FUNC,
    pub isZeroFunc: PSYMCRYPT_ECPOINT_ISZERO_FUNC,
    pub onCurveFunc: PSYMCRYPT_ECPOINT_ONCURVE_FUNC,
    pub addFunc: PSYMCRYPT_ECPOINT_ADD_FUNC,
    pub addDiffFunc: PSYMCRYPT_ECPOINT_ADD_DIFF_NONZERO_FUNC,
    pub doubleFunc: PSYMCRYPT_ECPOINT_DOUBLE_FUNC,
    pub negateFunc: PSYMCRYPT_ECPOINT_NEGATE_FUNC,
    pub scalarMulFunc: PSYMCRYPT_ECPOINT_SCALAR_MUL_FUNC,
    pub multiScalarMulFunc: PSYMCRYPT_ECPOINT_MULTI_SCALAR_MUL_FUNC,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_FUNCTIONS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_FUNCTIONS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_FUNCTIONS>(),
        96usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_FUNCTIONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_FUNCTIONS>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_FUNCTIONS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setZeroFunc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(setZeroFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setDistinguishedFunc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(setDistinguishedFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).setRandomFunc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(setRandomFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isEqualFunc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(isEqualFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isZeroFunc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(isZeroFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).onCurveFunc) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(onCurveFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addFunc) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(addFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addDiffFunc) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(addDiffFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).doubleFunc) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(doubleFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negateFunc) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(negateFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scalarMulFunc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(scalarMulFunc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multiScalarMulFunc) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_FUNCTIONS),
            "::",
            stringify!(multiScalarMulFunc)
        )
    );
}
pub type SYMCRYPT_ECURVE_FUNCTIONS = _SYMCRYPT_ECURVE_FUNCTIONS;
pub type PSYMCRYPT_ECURVE_FUNCTIONS = *mut _SYMCRYPT_ECURVE_FUNCTIONS;
pub type PCSYMCRYPT_ECURVE_FUNCTIONS = *const SYMCRYPT_ECURVE_FUNCTIONS;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_802_11_SAE_CUSTOM_STATE {
    pub pCurve: PSYMCRYPT_ECURVE,
    pub macAlgorithm: PCSYMCRYPT_MAC,
    pub peRand: PSYMCRYPT_MODELEMENT,
    pub peMask: PSYMCRYPT_MODELEMENT,
    pub poPWE: PSYMCRYPT_ECPOINT,
    pub counter: BYTE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_802_11_SAE_CUSTOM_STATE() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_802_11_SAE_CUSTOM_STATE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_802_11_SAE_CUSTOM_STATE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_802_11_SAE_CUSTOM_STATE>(),
        16usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pCurve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(pCurve)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).macAlgorithm) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(macAlgorithm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peRand) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(peRand)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).peMask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(peMask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).poPWE) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(poPWE)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_802_11_SAE_CUSTOM_STATE),
            "::",
            stringify!(counter)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_EXTENDED_SAVE_DATA {
    _unused: [u8; 0],
}
pub type SYMCRYPT_EXTENDED_SAVE_DATA = _SYMCRYPT_EXTENDED_SAVE_DATA;
pub type PSYMCRYPT_EXTENDED_SAVE_DATA = *mut _SYMCRYPT_EXTENDED_SAVE_DATA;
extern "C" {
    pub fn SymCryptWipe(pbData: PVOID, cbData: SIZE_T);
}
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_NONE:
    _SYMCRYPT_SELFTEST_ALGORITHM = 0;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_STARTUP:
    _SYMCRYPT_SELFTEST_ALGORITHM = 1;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_DSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 2;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_ECDSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 4;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_RSA:
    _SYMCRYPT_SELFTEST_ALGORITHM = 8;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_DH:
    _SYMCRYPT_SELFTEST_ALGORITHM = 16;
pub const _SYMCRYPT_SELFTEST_ALGORITHM_SYMCRYPT_SELFTEST_ALGORITHM_ECDH:
    _SYMCRYPT_SELFTEST_ALGORITHM = 32;
pub type _SYMCRYPT_SELFTEST_ALGORITHM = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_SELFTEST_ALGORITHM as SYMCRYPT_SELFTEST_ALGORITHM;
extern "C" {
    pub static mut g_SymCryptFipsSelftestsPerformed: UINT32;
}
extern "C" {
    pub fn SymCryptFipsGetSelftestsPerformed() -> UINT32;
}
extern "C" {
    pub fn SymCryptLoadLsbFirstUint32(
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptLoadLsbFirstUint64(
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT64,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptLoadMsbFirstUint32(
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptLoadMsbFirstUint64(
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pDst: PUINT64,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptStoreLsbFirstUint32(src: UINT32, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptStoreLsbFirstUint64(src: UINT64, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptStoreMsbFirstUint32(src: UINT32, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptStoreMsbFirstUint64(src: UINT64, pbDst: PBYTE, cbDst: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptUint32Bitsize(value: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptUint64Bitsize(value: UINT64) -> UINT32;
}
extern "C" {
    pub fn SymCryptUint32Bytesize(value: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptUint64Bytesize(value: UINT64) -> UINT32;
}
extern "C" {
    pub fn SymCryptInit();
}
extern "C" {
    pub fn SymCryptModuleInit(api: UINT32, minor: UINT32);
}
extern "C" {
    pub fn SymCryptXorBytes(pbSrc1: PCBYTE, pbSrc2: PCBYTE, pbResult: PBYTE, cbBytes: SIZE_T);
}
extern "C" {
    pub fn SymCryptEqual(pbSrc1: PCBYTE, pbSrc2: PCBYTE, cbBytes: SIZE_T) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptHashResultSize(pHash: PCSYMCRYPT_HASH) -> SIZE_T;
}
extern "C" {
    pub fn SymCryptHashInputBlockSize(pHash: PCSYMCRYPT_HASH) -> SIZE_T;
}
extern "C" {
    pub fn SymCryptHashStateSize(pHash: PCSYMCRYPT_HASH) -> SIZE_T;
}
extern "C" {
    pub fn SymCryptHash(
        pHash: PCSYMCRYPT_HASH,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHashInit(pHash: PCSYMCRYPT_HASH, pState: PVOID);
}
extern "C" {
    pub fn SymCryptHashAppend(
        pHash: PCSYMCRYPT_HASH,
        pState: PVOID,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHashResult(
        pHash: PCSYMCRYPT_HASH,
        pState: PVOID,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHashStateCopy(pHash: PCSYMCRYPT_HASH, pSrc: PCVOID, pDst: PVOID);
}
extern "C" {
    pub fn SymCryptMd2(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd2Init(pState: PSYMCRYPT_MD2_STATE);
}
extern "C" {
    pub fn SymCryptMd2Append(pState: PSYMCRYPT_MD2_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptMd2Result(pState: PSYMCRYPT_MD2_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd2StateCopy(pSrc: PCSYMCRYPT_MD2_STATE, pDst: PSYMCRYPT_MD2_STATE);
}
extern "C" {
    pub fn SymCryptMd2StateExport(pState: PCSYMCRYPT_MD2_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptMd2StateImport(pState: PSYMCRYPT_MD2_STATE, pbBlob: PCBYTE) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptMd2Selftest();
}
extern "C" {
    pub static SymCryptMd2Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptMd4(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd4Init(pState: PSYMCRYPT_MD4_STATE);
}
extern "C" {
    pub fn SymCryptMd4Append(pState: PSYMCRYPT_MD4_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptMd4Result(pState: PSYMCRYPT_MD4_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd4StateCopy(pSrc: PCSYMCRYPT_MD4_STATE, pDst: PSYMCRYPT_MD4_STATE);
}
extern "C" {
    pub fn SymCryptMd4StateExport(pState: PCSYMCRYPT_MD4_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptMd4StateImport(pState: PSYMCRYPT_MD4_STATE, pbBlob: PCBYTE) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptMd4Selftest();
}
extern "C" {
    pub static SymCryptMd4Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptMd5(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd5Init(pState: PSYMCRYPT_MD5_STATE);
}
extern "C" {
    pub fn SymCryptMd5Append(pState: PSYMCRYPT_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptMd5Result(pState: PSYMCRYPT_MD5_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMd5StateCopy(pSrc: PCSYMCRYPT_MD5_STATE, pDst: PSYMCRYPT_MD5_STATE);
}
extern "C" {
    pub fn SymCryptMd5StateExport(pState: PCSYMCRYPT_MD5_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptMd5StateImport(pState: PSYMCRYPT_MD5_STATE, pbBlob: PCBYTE) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptMd5Selftest();
}
extern "C" {
    pub static SymCryptMd5Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha1(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha1Init(pState: PSYMCRYPT_SHA1_STATE);
}
extern "C" {
    pub fn SymCryptSha1Append(pState: PSYMCRYPT_SHA1_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha1Result(pState: PSYMCRYPT_SHA1_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha1StateCopy(pSrc: PCSYMCRYPT_SHA1_STATE, pDst: PSYMCRYPT_SHA1_STATE);
}
extern "C" {
    pub fn SymCryptSha1StateExport(pState: PCSYMCRYPT_SHA1_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha1StateImport(pState: PSYMCRYPT_SHA1_STATE, pbBlob: PCBYTE) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha1Selftest();
}
extern "C" {
    pub static SymCryptSha1Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256Init(pState: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub fn SymCryptSha256Append(pState: PSYMCRYPT_SHA256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha256Result(pState: PSYMCRYPT_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256StateCopy(pSrc: PCSYMCRYPT_SHA256_STATE, pDst: PSYMCRYPT_SHA256_STATE);
}
extern "C" {
    pub fn SymCryptSha256StateExport(pState: PCSYMCRYPT_SHA256_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha256StateImport(
        pState: PSYMCRYPT_SHA256_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha256Selftest();
}
extern "C" {
    pub static SymCryptSha256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha384(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384Init(pState: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub fn SymCryptSha384Append(pState: PSYMCRYPT_SHA384_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha384Result(pState: PSYMCRYPT_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384StateCopy(pSrc: PCSYMCRYPT_SHA384_STATE, pDst: PSYMCRYPT_SHA384_STATE);
}
extern "C" {
    pub fn SymCryptSha384StateExport(pState: PCSYMCRYPT_SHA384_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha384StateImport(
        pState: PSYMCRYPT_SHA384_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha384Selftest();
}
extern "C" {
    pub static SymCryptSha384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha512(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha512Init(pState: PSYMCRYPT_SHA512_STATE);
}
extern "C" {
    pub fn SymCryptSha512Append(pState: PSYMCRYPT_SHA512_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha512Result(pState: PSYMCRYPT_SHA512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha512StateCopy(pSrc: PCSYMCRYPT_SHA512_STATE, pDst: PSYMCRYPT_SHA512_STATE);
}
extern "C" {
    pub fn SymCryptSha512StateExport(pState: PCSYMCRYPT_SHA512_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha512StateImport(
        pState: PSYMCRYPT_SHA512_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha512Selftest();
}
extern "C" {
    pub static SymCryptSha512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_256Init(pState: PSYMCRYPT_SHA3_256_STATE);
}
extern "C" {
    pub fn SymCryptSha3_256Append(pState: PSYMCRYPT_SHA3_256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_256Result(pState: PSYMCRYPT_SHA3_256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_256StateCopy(
        pSrc: PCSYMCRYPT_SHA3_256_STATE,
        pDst: PSYMCRYPT_SHA3_256_STATE,
    );
}
extern "C" {
    pub fn SymCryptSha3_256StateExport(pState: PCSYMCRYPT_SHA3_256_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_256StateImport(
        pState: PSYMCRYPT_SHA3_256_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha3_256Selftest();
}
extern "C" {
    pub static SymCryptSha3_256Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_384(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_384Init(pState: PSYMCRYPT_SHA3_384_STATE);
}
extern "C" {
    pub fn SymCryptSha3_384Append(pState: PSYMCRYPT_SHA3_384_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_384Result(pState: PSYMCRYPT_SHA3_384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_384StateCopy(
        pSrc: PCSYMCRYPT_SHA3_384_STATE,
        pDst: PSYMCRYPT_SHA3_384_STATE,
    );
}
extern "C" {
    pub fn SymCryptSha3_384StateExport(pState: PCSYMCRYPT_SHA3_384_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_384StateImport(
        pState: PSYMCRYPT_SHA3_384_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha3_384Selftest();
}
extern "C" {
    pub static SymCryptSha3_384Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptSha3_512(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_512Init(pState: PSYMCRYPT_SHA3_512_STATE);
}
extern "C" {
    pub fn SymCryptSha3_512Append(pState: PSYMCRYPT_SHA3_512_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptSha3_512Result(pState: PSYMCRYPT_SHA3_512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_512StateCopy(
        pSrc: PCSYMCRYPT_SHA3_512_STATE,
        pDst: PSYMCRYPT_SHA3_512_STATE,
    );
}
extern "C" {
    pub fn SymCryptSha3_512StateExport(pState: PCSYMCRYPT_SHA3_512_STATE, pbBlob: PBYTE);
}
extern "C" {
    pub fn SymCryptSha3_512StateImport(
        pState: PSYMCRYPT_SHA3_512_STATE,
        pbBlob: PCBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSha3_512Selftest();
}
extern "C" {
    pub static SymCryptSha3_512Algorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptShake128Default(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptShake128(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE, cbResult: SIZE_T);
}
extern "C" {
    pub fn SymCryptShake128Init(pState: PSYMCRYPT_SHAKE128_STATE);
}
extern "C" {
    pub fn SymCryptShake128Append(pState: PSYMCRYPT_SHAKE128_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptShake128Extract(
        pState: PSYMCRYPT_SHAKE128_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptShake128Result(pState: PSYMCRYPT_SHAKE128_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptShake128StateCopy(
        pSrc: PCSYMCRYPT_SHAKE128_STATE,
        pDst: PSYMCRYPT_SHAKE128_STATE,
    );
}
extern "C" {
    pub fn SymCryptShake128Selftest();
}
extern "C" {
    pub static SymCryptShake128HashAlgorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptShake256Default(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptShake256(pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE, cbResult: SIZE_T);
}
extern "C" {
    pub fn SymCryptShake256Init(pState: PSYMCRYPT_SHAKE256_STATE);
}
extern "C" {
    pub fn SymCryptShake256Append(pState: PSYMCRYPT_SHAKE256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptShake256Extract(
        pState: PSYMCRYPT_SHAKE256_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptShake256Result(pState: PSYMCRYPT_SHAKE256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptShake256StateCopy(
        pSrc: PCSYMCRYPT_SHAKE256_STATE,
        pDst: PSYMCRYPT_SHAKE256_STATE,
    );
}
extern "C" {
    pub fn SymCryptShake256Selftest();
}
extern "C" {
    pub static SymCryptShake256HashAlgorithm: PCSYMCRYPT_HASH;
}
extern "C" {
    pub fn SymCryptCShake128(
        pbFunctionNameString: PCBYTE,
        cbFunctionNameString: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake128Init(
        pState: PSYMCRYPT_CSHAKE128_STATE,
        pbFunctionNameString: PCBYTE,
        cbFunctionNameString: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake128Append(
        pState: PSYMCRYPT_CSHAKE128_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake128Extract(
        pState: PSYMCRYPT_CSHAKE128_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptCShake128Result(pState: PSYMCRYPT_CSHAKE128_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptCShake128StateCopy(
        pSrc: PCSYMCRYPT_CSHAKE128_STATE,
        pDst: PSYMCRYPT_CSHAKE128_STATE,
    );
}
extern "C" {
    pub fn SymCryptCShake128Selftest();
}
extern "C" {
    pub fn SymCryptCShake256(
        pbFunctionNameString: PCBYTE,
        cbFunctionNameString: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake256Init(
        pState: PSYMCRYPT_CSHAKE256_STATE,
        pbFunctionNameString: PCBYTE,
        cbFunctionNameString: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake256Append(
        pState: PSYMCRYPT_CSHAKE256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCShake256Extract(
        pState: PSYMCRYPT_CSHAKE256_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptCShake256Result(pState: PSYMCRYPT_CSHAKE256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptCShake256StateCopy(
        pSrc: PCSYMCRYPT_CSHAKE256_STATE,
        pDst: PSYMCRYPT_CSHAKE256_STATE,
    );
}
extern "C" {
    pub fn SymCryptCShake256Selftest();
}
extern "C" {
    pub fn SymCryptParallelSha256Init(pStates: PSYMCRYPT_SHA256_STATE, nStates: SIZE_T);
}
extern "C" {
    pub fn SymCryptParallelSha256Process(
        pStates: PSYMCRYPT_SHA256_STATE,
        nStates: SIZE_T,
        pOperations: PSYMCRYPT_PARALLEL_HASH_OPERATION,
        nOperations: SIZE_T,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptParallelSha384Init(pStates: PSYMCRYPT_SHA384_STATE, nStates: SIZE_T);
}
extern "C" {
    pub fn SymCryptParallelSha384Process(
        pStates: PSYMCRYPT_SHA384_STATE,
        nStates: SIZE_T,
        pOperations: PSYMCRYPT_PARALLEL_HASH_OPERATION,
        nOperations: SIZE_T,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptParallelSha512Init(pStates: PSYMCRYPT_SHA512_STATE, nStates: SIZE_T);
}
extern "C" {
    pub fn SymCryptParallelSha512Process(
        pStates: PSYMCRYPT_SHA512_STATE,
        nStates: SIZE_T,
        pOperations: PSYMCRYPT_PARALLEL_HASH_OPERATION,
        nOperations: SIZE_T,
        pbScratch: PBYTE,
        cbScratch: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptParallelSha256Selftest();
}
extern "C" {
    pub fn SymCryptParallelSha384Selftest();
}
extern "C" {
    pub fn SymCryptParallelSha512Selftest();
}
extern "C" {
    pub fn SymCryptHmacMd5ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacMd5KeyCopy(
        pSrc: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5(
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5StateCopy(
        pSrc: PCSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_MD5_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5Init(
        pState: PSYMCRYPT_HMAC_MD5_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_MD5_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacMd5Append(pState: PSYMCRYPT_HMAC_MD5_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptHmacMd5Result(pState: PSYMCRYPT_HMAC_MD5_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacMd5Selftest();
}
extern "C" {
    pub static SymCryptHmacMd5Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha1ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha1KeyCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA1_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Init(
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA1_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Append(
        pState: PSYMCRYPT_HMAC_SHA1_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha1Result(pState: PSYMCRYPT_HMAC_SHA1_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacSha1Selftest();
}
extern "C" {
    pub static SymCryptHmacSha1Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha256ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha256KeyCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA256_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Init(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Append(
        pState: PSYMCRYPT_HMAC_SHA256_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha256Result(pState: PSYMCRYPT_HMAC_SHA256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacSha256Selftest();
}
extern "C" {
    pub static SymCryptHmacSha256Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha384ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha384KeyCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA384_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Init(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA384_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Append(
        pState: PSYMCRYPT_HMAC_SHA384_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha384Result(pState: PSYMCRYPT_HMAC_SHA384_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacSha384Selftest();
}
extern "C" {
    pub static SymCryptHmacSha384Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptHmacSha512ExpandKey(
        pExpandedKey: PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHmacSha512KeyCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512(
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512StateCopy(
        pSrc: PCSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
        pDst: PSYMCRYPT_HMAC_SHA512_STATE,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Init(
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pExpandedKey: PCSYMCRYPT_HMAC_SHA512_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Append(
        pState: PSYMCRYPT_HMAC_SHA512_STATE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptHmacSha512Result(pState: PSYMCRYPT_HMAC_SHA512_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptHmacSha512Selftest();
}
extern "C" {
    pub static SymCryptHmacSha512Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptAesCmacExpandKey(
        pExpandedKey: PSYMCRYPT_AES_CMAC_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptAesCmacKeyCopy(
        pSrc: PCSYMCRYPT_AES_CMAC_EXPANDED_KEY,
        pDst: PSYMCRYPT_AES_CMAC_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptAesCmac(
        pExpandedKey: PSYMCRYPT_AES_CMAC_EXPANDED_KEY,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptAesCmacStateCopy(
        pSrc: PCSYMCRYPT_AES_CMAC_STATE,
        pExpandedKey: PCSYMCRYPT_AES_CMAC_EXPANDED_KEY,
        pDst: PSYMCRYPT_AES_CMAC_STATE,
    );
}
extern "C" {
    pub fn SymCryptAesCmacInit(
        pState: PSYMCRYPT_AES_CMAC_STATE,
        pExpandedKey: PCSYMCRYPT_AES_CMAC_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptAesCmacAppend(pState: PSYMCRYPT_AES_CMAC_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptAesCmacResult(pState: PSYMCRYPT_AES_CMAC_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptAesCmacSelftest();
}
extern "C" {
    pub static SymCryptAesCmacAlgorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptKmac128(
        pExpandedKey: PCSYMCRYPT_KMAC128_EXPANDED_KEY,
        pbInput: PCBYTE,
        cbInput: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptKmac128Ex(
        pExpandedKey: PCSYMCRYPT_KMAC128_EXPANDED_KEY,
        pbInput: PCBYTE,
        cbInput: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptKmac128ExpandKey(
        pExpandedKey: PSYMCRYPT_KMAC128_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptKmac128ExpandKeyEx(
        pExpandedKey: PSYMCRYPT_KMAC128_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptKmac128Init(
        pState: PSYMCRYPT_KMAC128_STATE,
        pExpandedKey: PCSYMCRYPT_KMAC128_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptKmac128Append(pState: PSYMCRYPT_KMAC128_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptKmac128Extract(
        pState: PSYMCRYPT_KMAC128_STATE,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptKmac128Result(pState: PSYMCRYPT_KMAC128_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptKmac128ResultEx(
        pState: PSYMCRYPT_KMAC128_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptKmac128KeyCopy(
        pSrc: PCSYMCRYPT_KMAC128_EXPANDED_KEY,
        pDst: PSYMCRYPT_KMAC128_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptKmac128StateCopy(
        pSrc: *const SYMCRYPT_KMAC128_STATE,
        pDst: *mut SYMCRYPT_KMAC128_STATE,
    );
}
extern "C" {
    pub fn SymCryptKmac128Selftest();
}
extern "C" {
    pub static SymCryptKmac128Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptKmac256(
        pExpandedKey: PCSYMCRYPT_KMAC256_EXPANDED_KEY,
        pbInput: PCBYTE,
        cbInput: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptKmac256Ex(
        pExpandedKey: PCSYMCRYPT_KMAC256_EXPANDED_KEY,
        pbInput: PCBYTE,
        cbInput: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptKmac256ExpandKey(
        pExpandedKey: PSYMCRYPT_KMAC256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptKmac256ExpandKeyEx(
        pExpandedKey: PSYMCRYPT_KMAC256_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbCustomizationString: PCBYTE,
        cbCustomizationString: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptKmac256Init(
        pState: PSYMCRYPT_KMAC256_STATE,
        pExpandedKey: PCSYMCRYPT_KMAC256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptKmac256Append(pState: PSYMCRYPT_KMAC256_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptKmac256Extract(
        pState: PSYMCRYPT_KMAC256_STATE,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
        bWipe: BOOLEAN,
    );
}
extern "C" {
    pub fn SymCryptKmac256Result(pState: PSYMCRYPT_KMAC256_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptKmac256ResultEx(
        pState: PSYMCRYPT_KMAC256_STATE,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptKmac256KeyCopy(
        pSrc: PCSYMCRYPT_KMAC256_EXPANDED_KEY,
        pDst: PSYMCRYPT_KMAC256_EXPANDED_KEY,
    );
}
extern "C" {
    pub fn SymCryptKmac256StateCopy(
        pSrc: *const SYMCRYPT_KMAC256_STATE,
        pDst: *mut SYMCRYPT_KMAC256_STATE,
    );
}
extern "C" {
    pub fn SymCryptKmac256Selftest();
}
extern "C" {
    pub static SymCryptKmac256Algorithm: PCSYMCRYPT_MAC;
}
extern "C" {
    pub fn SymCryptPoly1305(pbKey: PCBYTE, pbData: PCBYTE, cbData: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptPoly1305Init(pState: PSYMCRYPT_POLY1305_STATE, pbKey: PCBYTE);
}
extern "C" {
    pub fn SymCryptPoly1305Append(pState: PSYMCRYPT_POLY1305_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptPoly1305Result(pState: PSYMCRYPT_POLY1305_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptPoly1305Selftest();
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Encrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Decrypt(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptChaCha20Poly1305Selftest();
}
extern "C" {
    pub fn SymCryptMarvin32ExpandSeed(
        pExpandedSeed: PSYMCRYPT_MARVIN32_EXPANDED_SEED,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub static SymCryptMarvin32DefaultSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED;
}
extern "C" {
    pub fn SymCryptMarvin32SeedCopy(
        pSrc: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
        pDst: PSYMCRYPT_MARVIN32_EXPANDED_SEED,
    );
}
extern "C" {
    pub fn SymCryptMarvin32(
        pExpandedSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
        pbData: PCBYTE,
        cbData: SIZE_T,
        pbResult: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptMarvin32StateCopy(
        pSrc: PCSYMCRYPT_MARVIN32_STATE,
        pExpandedSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
        pDst: PSYMCRYPT_MARVIN32_STATE,
    );
}
extern "C" {
    pub fn SymCryptMarvin32Init(
        pState: PSYMCRYPT_MARVIN32_STATE,
        pExpandedSeed: PCSYMCRYPT_MARVIN32_EXPANDED_SEED,
    );
}
extern "C" {
    pub fn SymCryptMarvin32Append(pState: PSYMCRYPT_MARVIN32_STATE, pbData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptMarvin32Result(pState: PSYMCRYPT_MARVIN32_STATE, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptMarvin32Selftest();
}
extern "C" {
    pub fn SymCryptAesExpandKey(
        pExpandedKey: PSYMCRYPT_AES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptAesExpandKeyEncryptOnly(
        pExpandedKey: PSYMCRYPT_AES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptAesKeyCopy(pSrc: PCSYMCRYPT_AES_EXPANDED_KEY, pDst: PSYMCRYPT_AES_EXPANDED_KEY);
}
extern "C" {
    pub fn SymCryptAesEncrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptAesDecrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptAesEcbEncrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesEcbDecrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesCbcEncrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesCbcDecrypt(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesCbcMac(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbData: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesCtrMsb64(
        pExpandedKey: PCSYMCRYPT_AES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptAesSelftest(maskTestsToRun: UINT32);
}
extern "C" {
    pub static SymCryptAesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptDesExpandKey(
        pExpandedKey: PSYMCRYPT_DES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDesEncrypt(
        pExpandedKey: PCSYMCRYPT_DES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptDesDecrypt(
        pExpandedKey: PCSYMCRYPT_DES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptDesSetOddParity(pbData: PBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptDesSelftest();
}
extern "C" {
    pub static SymCryptDesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCrypt3DesExpandKey(
        pExpandedKey: PSYMCRYPT_3DES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCrypt3DesEncrypt(
        pExpandedKey: PCSYMCRYPT_3DES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCrypt3DesDecrypt(
        pExpandedKey: PCSYMCRYPT_3DES_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCrypt3DesCbcEncrypt(
        pExpandedKey: PCSYMCRYPT_3DES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCrypt3DesCbcDecrypt(
        pExpandedKey: PCSYMCRYPT_3DES_EXPANDED_KEY,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCrypt3DesSelftest();
}
extern "C" {
    pub static SymCrypt3DesBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptDesxExpandKey(
        pExpandedKey: PSYMCRYPT_DESX_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDesxEncrypt(
        pExpandedKey: PCSYMCRYPT_DESX_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptDesxDecrypt(
        pExpandedKey: PCSYMCRYPT_DESX_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptDesxSelftest();
}
extern "C" {
    pub static SymCryptDesxBlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptRc2ExpandKey(
        pExpandedKey: PSYMCRYPT_RC2_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRc2ExpandKeyEx(
        pExpandedKey: PSYMCRYPT_RC2_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        effectiveKeySizeInBits: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRc2Encrypt(
        pExpandedKey: PCSYMCRYPT_RC2_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptRc2Decrypt(
        pExpandedKey: PCSYMCRYPT_RC2_EXPANDED_KEY,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
    );
}
extern "C" {
    pub fn SymCryptRc2Selftest();
}
extern "C" {
    pub static SymCryptRc2BlockCipher: PCSYMCRYPT_BLOCKCIPHER;
}
extern "C" {
    pub fn SymCryptEcbEncrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptEcbDecrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCbcEncrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCbcDecrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCbcMac(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCtrMsb64(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCfbEncrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbShift: SIZE_T,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCfbDecrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbShift: SIZE_T,
        pExpandedKey: PCVOID,
        pbChainingValue: PBYTE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptPaddingPkcs7Add(
        cbBlockSize: SIZE_T,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbResult: *mut SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptPaddingPkcs7Remove(
        cbBlockSize: SIZE_T,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbResult: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCcmValidateParameters(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbNonce: SIZE_T,
        cbAssociatedData: SIZE_T,
        cbData: UINT64,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCcmEncrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCcmDecrypt(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCcmInit(
        pState: PSYMCRYPT_CCM_STATE,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pExpandedKey: PCVOID,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        cbData: UINT64,
        cbTag: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCcmEncryptPart(
        pState: PSYMCRYPT_CCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCcmEncryptFinal(pState: PSYMCRYPT_CCM_STATE, pbTag: PBYTE, cbTag: SIZE_T);
}
extern "C" {
    pub fn SymCryptCcmDecryptPart(
        pState: PSYMCRYPT_CCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptCcmDecryptFinal(
        pState: PSYMCRYPT_CCM_STATE,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCcmSelftest();
}
extern "C" {
    pub fn SymCryptGcmValidateParameters(
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        cbNonce: SIZE_T,
        cbAssociatedData: UINT64,
        cbData: UINT64,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmExpandKey(
        pExpandedKey: PSYMCRYPT_GCM_EXPANDED_KEY,
        pBlockCipher: PCSYMCRYPT_BLOCKCIPHER,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmKeyCopy(pSrc: PCSYMCRYPT_GCM_EXPANDED_KEY, pDst: PSYMCRYPT_GCM_EXPANDED_KEY);
}
extern "C" {
    pub fn SymCryptGcmEncrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecrypt(
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmInit(
        pState: PSYMCRYPT_GCM_STATE,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmStateCopy(
        pSrc: PCSYMCRYPT_GCM_STATE,
        pExpandedKeyCopy: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pDst: PSYMCRYPT_GCM_STATE,
    );
}
extern "C" {
    pub fn SymCryptGcmAuthPart(pState: PSYMCRYPT_GCM_STATE, pbAuthData: PCBYTE, cbData: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmEncryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmEncryptFinal(pState: PSYMCRYPT_GCM_STATE, pbTag: PBYTE, cbTag: SIZE_T);
}
extern "C" {
    pub fn SymCryptGcmDecryptPart(
        pState: PSYMCRYPT_GCM_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptGcmDecryptFinal(
        pState: PSYMCRYPT_GCM_STATE,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptGcmSelftest();
}
extern "C" {
    pub fn SymCryptSessionSenderInit(
        pSession: PSYMCRYPT_SESSION,
        senderId: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSessionReceiverInit(
        pSession: PSYMCRYPT_SESSION,
        senderId: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSessionDestroy(pSession: PSYMCRYPT_SESSION);
}
extern "C" {
    pub fn SymCryptSessionGcmEncrypt(
        pSession: PSYMCRYPT_SESSION,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PBYTE,
        cbTag: SIZE_T,
        pu64MessageNumber: PUINT64,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSessionGcmDecrypt(
        pSession: PSYMCRYPT_SESSION,
        messageNumber: UINT64,
        pExpandedKey: PCSYMCRYPT_GCM_EXPANDED_KEY,
        pbAuthData: PCBYTE,
        cbAuthData: SIZE_T,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
        pbTag: PCBYTE,
        cbTag: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRc4Init(
        pState: PSYMCRYPT_RC4_STATE,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRc4Crypt(
        pState: PSYMCRYPT_RC4_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptRc4Selftest();
}
extern "C" {
    pub fn SymCryptChaCha20Init(
        pState: PSYMCRYPT_CHACHA20_STATE,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbNonce: PCBYTE,
        cbNonce: SIZE_T,
        offset: UINT64,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptChaCha20SetOffset(pState: PSYMCRYPT_CHACHA20_STATE, offset: UINT64);
}
extern "C" {
    pub fn SymCryptChaCha20Crypt(
        pState: PSYMCRYPT_CHACHA20_STATE,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptChaCha20Selftest();
}
extern "C" {
    pub fn SymCryptPbkdf2ExpandKey(
        pExpandedKey: PSYMCRYPT_PBKDF2_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptPbkdf2Derive(
        pExpandedKey: PCSYMCRYPT_PBKDF2_EXPANDED_KEY,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        iterationCnt: UINT64,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptPbkdf2(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        iterationCnt: UINT64,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptPbkdf2_HmacSha1SelfTest();
}
extern "C" {
    pub fn SymCryptPbkdf2_HmacSha256SelfTest();
}
extern "C" {
    pub fn SymCryptSp800_108ExpandKey(
        pExpandedKey: PSYMCRYPT_SP800_108_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSp800_108Derive(
        pExpandedKey: PCSYMCRYPT_SP800_108_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbContext: PCBYTE,
        cbContext: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSp800_108(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbContext: PCBYTE,
        cbContext: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSp800_108_HmacSha1SelfTest();
}
extern "C" {
    pub fn SymCryptSp800_108_HmacSha256SelfTest();
}
extern "C" {
    pub fn SymCryptSp800_108_HmacSha384SelfTest();
}
extern "C" {
    pub fn SymCryptSp800_108_HmacSha512SelfTest();
}
extern "C" {
    pub fn SymCryptTlsPrf1_1ExpandKey(
        pExpandedKey: PSYMCRYPT_TLSPRF1_1_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_1Derive(
        pExpandedKey: PCSYMCRYPT_TLSPRF1_1_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_1(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_1SelfTest();
}
extern "C" {
    pub fn SymCryptTlsPrf1_2ExpandKey(
        pExpandedKey: PSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2Derive(
        pExpandedKey: PCSYMCRYPT_TLSPRF1_2_EXPANDED_KEY,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptTlsPrf1_2SelfTest();
}
extern "C" {
    pub fn SymCryptSshKdfExpandKey(
        pExpandedKey: PSYMCRYPT_SSHKDF_EXPANDED_KEY,
        pHashFunc: PCSYMCRYPT_HASH,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSshKdfDerive(
        pExpandedKey: PCSYMCRYPT_SSHKDF_EXPANDED_KEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        label: BYTE,
        pbSessionId: PCBYTE,
        cbSessionId: SIZE_T,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSshKdf(
        pHashFunc: PCSYMCRYPT_HASH,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        label: BYTE,
        pbSessionId: PCBYTE,
        cbSessionId: SIZE_T,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSshKdfSha256SelfTest();
}
extern "C" {
    pub fn SymCryptSshKdfSha512SelfTest();
}
extern "C" {
    pub fn SymCryptSrtpKdfExpandKey(
        pExpandedKey: PSYMCRYPT_SRTPKDF_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSrtpKdfDerive(
        pExpandedKey: PCSYMCRYPT_SRTPKDF_EXPANDED_KEY,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        uKeyDerivationRate: UINT32,
        uIndex: UINT64,
        uIndexWidth: UINT32,
        label: BYTE,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSrtpKdf(
        pbKey: PCBYTE,
        cbKey: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        uKeyDerivationRate: UINT32,
        uIndex: UINT64,
        uIndexWidth: UINT32,
        label: BYTE,
        pbOutput: PBYTE,
        cbOutput: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptSrtpKdfSelfTest();
}
extern "C" {
    pub fn SymCryptHkdfExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfExtractPrk(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbPrk: PBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfPrkExpandKey(
        pExpandedKey: PSYMCRYPT_HKDF_EXPANDED_KEY,
        macAlgorithm: PCSYMCRYPT_MAC,
        pbPrk: PCBYTE,
        cbPrk: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfDerive(
        pExpandedKey: PCSYMCRYPT_HKDF_EXPANDED_KEY,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdf(
        macAlgorithm: PCSYMCRYPT_MAC,
        pbIkm: PCBYTE,
        cbIkm: SIZE_T,
        pbSalt: PCBYTE,
        cbSalt: SIZE_T,
        pbInfo: PCBYTE,
        cbInfo: SIZE_T,
        pbResult: PBYTE,
        cbResult: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptHkdfSelfTest();
}
extern "C" {
    pub fn SymCryptRngAesInstantiate(
        pRngState: PSYMCRYPT_RNG_AES_STATE,
        pcbSeedMaterial: PCBYTE,
        cbSeedMaterial: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRngAesGenerate(
        pRngState: PSYMCRYPT_RNG_AES_STATE,
        pbRandom: PBYTE,
        cbRandom: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptRngAesReseed(
        pRngState: PSYMCRYPT_RNG_AES_STATE,
        pcbSeedMaterial: PCBYTE,
        cbSeedMaterial: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRngAesUninstantiate(pRngState: PSYMCRYPT_RNG_AES_STATE);
}
extern "C" {
    pub fn SymCryptRngAesInstantiateSelftest();
}
extern "C" {
    pub fn SymCryptRngAesReseedSelftest();
}
extern "C" {
    pub fn SymCryptRngAesGenerateSelftest();
}
extern "C" {
    pub fn SymCryptRngAesFips140_2Instantiate(
        pRngState: PSYMCRYPT_RNG_AES_FIPS140_2_STATE,
        pcbSeedMaterial: PCBYTE,
        cbSeedMaterial: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRngAesFips140_2Generate(
        pRngState: PSYMCRYPT_RNG_AES_FIPS140_2_STATE,
        pbRandom: PBYTE,
        cbRandom: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptRngAesFips140_2Reseed(
        pRngState: PSYMCRYPT_RNG_AES_FIPS140_2_STATE,
        pcbSeedMaterial: PCBYTE,
        cbSeedMaterial: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRngAesFips140_2Uninstantiate(pRngState: PSYMCRYPT_RNG_AES_FIPS140_2_STATE);
}
extern "C" {
    pub fn SymCryptRandom(pbRandom: PBYTE, cbRandom: SIZE_T);
}
extern "C" {
    pub fn SymCryptProvideEntropy(pbEntropy: PCBYTE, cbEntropy: SIZE_T);
}
extern "C" {
    pub fn SymCryptRdrandStatus() -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRdrandGetBytes(
        pbBuffer: PBYTE,
        cbBuffer: SIZE_T,
        pbResult: PBYTE,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRdrandGet(pbBuffer: PBYTE, cbBuffer: SIZE_T, pbResult: PBYTE);
}
extern "C" {
    pub fn SymCryptRdseedStatus() -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRdseedGetBytes(pbResult: PBYTE, cbResult: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRdseedGet(pbResult: PBYTE, cbResult: SIZE_T);
}
extern "C" {
    pub fn SymCryptXtsAesExpandKey(
        pExpandedKey: PSYMCRYPT_XTS_AES_EXPANDED_KEY,
        pbKey: PCBYTE,
        cbKey: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptXtsAesEncrypt(
        pExpandedKey: PCSYMCRYPT_XTS_AES_EXPANDED_KEY,
        cbDataUnit: SIZE_T,
        tweak: UINT64,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptXtsAesDecrypt(
        pExpandedKey: PCSYMCRYPT_XTS_AES_EXPANDED_KEY,
        cbDataUnit: SIZE_T,
        tweak: UINT64,
        pbSrc: PCBYTE,
        pbDst: PBYTE,
        cbData: SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptXtsAesSelftest();
}
extern "C" {
    pub fn SymCryptTlsCbcHmacVerify(
        pMacAlgorithm: PCSYMCRYPT_MAC,
        pExpandedKey: PVOID,
        pState: PVOID,
        pbData: PCBYTE,
        cbData: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCallbackAlloc(nBytes: SIZE_T) -> PVOID;
}
extern "C" {
    pub fn SymCryptCallbackFree(pMem: PVOID);
}
extern "C" {
    pub fn SymCryptCallbackRandom(pbBuffer: PBYTE, cbBuffer: SIZE_T) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptCallbackAllocateMutexFastInproc() -> PVOID;
}
extern "C" {
    pub fn SymCryptCallbackFreeMutexFastInproc(pMutex: PVOID);
}
extern "C" {
    pub fn SymCryptCallbackAcquireMutexFastInproc(pMutex: PVOID);
}
extern "C" {
    pub fn SymCryptCallbackReleaseMutexFastInproc(pMutex: PVOID);
}
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_LSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 1;
pub const _SYMCRYPT_NUMBER_FORMAT_SYMCRYPT_NUMBER_FORMAT_MSB_FIRST: _SYMCRYPT_NUMBER_FORMAT = 2;
pub type _SYMCRYPT_NUMBER_FORMAT = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_NUMBER_FORMAT as SYMCRYPT_NUMBER_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_RSA_PARAMS {
    pub version: UINT32,
    pub nBitsOfModulus: UINT32,
    pub nPrimes: UINT32,
    pub nPubExp: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_RSA_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_RSA_PARAMS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_RSA_PARAMS>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_RSA_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_RSA_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_RSA_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nBitsOfModulus) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nBitsOfModulus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPrimes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nPrimes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nPubExp) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_RSA_PARAMS),
            "::",
            stringify!(nPubExp)
        )
    );
}
pub type SYMCRYPT_RSA_PARAMS = _SYMCRYPT_RSA_PARAMS;
pub type PSYMCRYPT_RSA_PARAMS = *mut _SYMCRYPT_RSA_PARAMS;
pub type PCSYMCRYPT_RSA_PARAMS = *const SYMCRYPT_RSA_PARAMS;
pub const _SYMCRYPT_ECURVE_GEN_ALG_ID_SYMCRYPT_ECURVE_GEN_ALG_ID_NULL: _SYMCRYPT_ECURVE_GEN_ALG_ID =
    0;
pub type _SYMCRYPT_ECURVE_GEN_ALG_ID = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECURVE_GEN_ALG_ID as SYMCRYPT_ECURVE_GEN_ALG_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION {
    pub PrivateKeyDefaultFormat: UINT32,
    pub HighBitRestrictionNumOfBits: UINT32,
    pub HighBitRestrictionPosition: UINT32,
    pub HighBitRestrictionValue: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).PrivateKeyDefaultFormat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION),
            "::",
            stringify!(PrivateKeyDefaultFormat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionNumOfBits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION),
            "::",
            stringify!(HighBitRestrictionNumOfBits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionPosition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION),
            "::",
            stringify!(HighBitRestrictionPosition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HighBitRestrictionValue) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION),
            "::",
            stringify!(HighBitRestrictionValue)
        )
    );
}
pub type SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub type PSYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = *mut _SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub type PCSYMCRYPT_ECURVE_PARAMS_V2_EXTENSION = *const SYMCRYPT_ECURVE_PARAMS_V2_EXTENSION;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_NULL:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 0;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_CANONICAL:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 1;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_DIVH:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 2;
pub const _SYMCRYPT_ECKEY_PRIVATE_FORMAT_SYMCRYPT_ECKEY_PRIVATE_FORMAT_DIVH_TIMESH:
    _SYMCRYPT_ECKEY_PRIVATE_FORMAT = 3;
pub type _SYMCRYPT_ECKEY_PRIVATE_FORMAT = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECKEY_PRIVATE_FORMAT as SYMCRYPT_ECKEY_PRIVATE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_ECURVE_PARAMS {
    pub version: UINT32,
    pub type_: SYMCRYPT_ECURVE_TYPE,
    pub algId: SYMCRYPT_ECURVE_GEN_ALG_ID,
    pub cbFieldLength: UINT32,
    pub cbSubgroupOrder: UINT32,
    pub cbCofactor: UINT32,
    pub cbSeed: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_ECURVE_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_ECURVE_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        28usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_ECURVE_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_ECURVE_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).algId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(algId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbFieldLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbFieldLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSubgroupOrder) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSubgroupOrder)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbCofactor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbCofactor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbSeed) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_ECURVE_PARAMS),
            "::",
            stringify!(cbSeed)
        )
    );
}
pub type SYMCRYPT_ECURVE_PARAMS = _SYMCRYPT_ECURVE_PARAMS;
pub type PSYMCRYPT_ECURVE_PARAMS = *mut _SYMCRYPT_ECURVE_PARAMS;
pub type PCSYMCRYPT_ECURVE_PARAMS = *const SYMCRYPT_ECURVE_PARAMS;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_X: _SYMCRYPT_ECPOINT_FORMAT = 1;
pub const _SYMCRYPT_ECPOINT_FORMAT_SYMCRYPT_ECPOINT_FORMAT_XY: _SYMCRYPT_ECPOINT_FORMAT = 2;
pub type _SYMCRYPT_ECPOINT_FORMAT = ::std::os::raw::c_uint;
pub use self::_SYMCRYPT_ECPOINT_FORMAT as SYMCRYPT_ECPOINT_FORMAT;
extern "C" {
    pub fn SymCryptRsakeyAllocate(
        pParams: PCSYMCRYPT_RSA_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_RSAKEY;
}
extern "C" {
    pub fn SymCryptRsakeyFree(pkObj: PSYMCRYPT_RSAKEY);
}
extern "C" {
    pub fn SymCryptSizeofRsakeyFromParams(pParams: PCSYMCRYPT_RSA_PARAMS) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyCreate(
        pbBuffer: PBYTE,
        cbBuffer: SIZE_T,
        pParams: PCSYMCRYPT_RSA_PARAMS,
    ) -> PSYMCRYPT_RSAKEY;
}
extern "C" {
    pub fn SymCryptRsakeyWipe(pkDst: PSYMCRYPT_RSAKEY);
}
extern "C" {
    pub fn SymCryptDlgroupAllocate(nBitsOfP: UINT32, nBitsOfQ: UINT32) -> PSYMCRYPT_DLGROUP;
}
extern "C" {
    pub fn SymCryptDlgroupFree(pgObj: PSYMCRYPT_DLGROUP);
}
extern "C" {
    pub fn SymCryptSizeofDlgroupFromBitsizes(nBitsOfP: UINT32, nBitsOfQ: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptDlgroupCreate(
        pbBuffer: PBYTE,
        cbBuffer: SIZE_T,
        nBitsOfP: UINT32,
        nBitsOfQ: UINT32,
    ) -> PSYMCRYPT_DLGROUP;
}
extern "C" {
    pub fn SymCryptDlgroupWipe(pgDst: PSYMCRYPT_DLGROUP);
}
extern "C" {
    pub fn SymCryptDlgroupCopy(pgSrc: PCSYMCRYPT_DLGROUP, pgDst: PSYMCRYPT_DLGROUP);
}
extern "C" {
    pub fn SymCryptDlkeyAllocate(pDlgroup: PCSYMCRYPT_DLGROUP) -> PSYMCRYPT_DLKEY;
}
extern "C" {
    pub fn SymCryptDlkeyFree(pkObj: PSYMCRYPT_DLKEY);
}
extern "C" {
    pub fn SymCryptSizeofDlkeyFromDlgroup(pDlgroup: PCSYMCRYPT_DLGROUP) -> UINT32;
}
extern "C" {
    pub fn SymCryptDlkeyCreate(
        pbBuffer: PBYTE,
        cbBuffer: SIZE_T,
        pDlgroup: PCSYMCRYPT_DLGROUP,
    ) -> PSYMCRYPT_DLKEY;
}
extern "C" {
    pub fn SymCryptDlkeyWipe(pkDst: PSYMCRYPT_DLKEY);
}
extern "C" {
    pub fn SymCryptDlkeyCopy(pkSrc: PCSYMCRYPT_DLKEY, pkDst: PSYMCRYPT_DLKEY);
}
extern "C" {
    pub fn SymCryptEcurveAllocate(
        pParams: PCSYMCRYPT_ECURVE_PARAMS,
        flags: UINT32,
    ) -> PSYMCRYPT_ECURVE;
}
extern "C" {
    pub fn SymCryptEcurveFree(pCurve: PSYMCRYPT_ECURVE);
}
extern "C" {
    pub fn SymCryptEckeyAllocate(pCurve: PCSYMCRYPT_ECURVE) -> PSYMCRYPT_ECKEY;
}
extern "C" {
    pub fn SymCryptEckeyFree(pkObj: PSYMCRYPT_ECKEY);
}
extern "C" {
    pub fn SymCryptSizeofEckeyFromCurve(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeyCreate(
        pbBuffer: PBYTE,
        cbBuffer: SIZE_T,
        pCurve: PCSYMCRYPT_ECURVE,
    ) -> PSYMCRYPT_ECKEY;
}
extern "C" {
    pub fn SymCryptEckeyWipe(pkDst: PSYMCRYPT_ECKEY);
}
extern "C" {
    pub fn SymCryptEckeyCopy(pkSrc: PCSYMCRYPT_ECKEY, pkDst: PSYMCRYPT_ECKEY);
}
extern "C" {
    pub fn SymCryptRsakeyHasPrivateKey(pkRsakey: PCSYMCRYPT_RSAKEY) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptRsakeySizeofModulus(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyModulusBits(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeySizeofPublicExponent(pRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeySizeofPrime(pkRsakey: PCSYMCRYPT_RSAKEY, index: UINT32) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGetNumberOfPublicExponents(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGetNumberOfPrimes(pkRsakey: PCSYMCRYPT_RSAKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptRsakeyGenerate(
        pkRsakey: PSYMCRYPT_RSAKEY,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeySetValue(
        pbModulus: PCBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PCUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PCBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pkRsakey: PSYMCRYPT_RSAKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyGetValue(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbModulus: PBYTE,
        cbModulus: SIZE_T,
        pu64PubExp: PUINT64,
        nPubExp: UINT32,
        ppPrimes: *mut PBYTE,
        pcbPrimes: *mut SIZE_T,
        nPrimes: UINT32,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyGetCrtValue(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        ppCrtExponents: *mut PBYTE,
        pcbCrtExponents: *mut SIZE_T,
        nCrtExponents: UINT32,
        pbCrtCoefficient: PBYTE,
        cbCrtCoefficient: SIZE_T,
        pbPrivateExponent: PBYTE,
        cbPrivateExponent: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsakeyExtendKeyUsage(
        pkRsakey: PSYMCRYPT_RSAKEY,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlgroupGenerate(
        hashAlgorithm: PCSYMCRYPT_HASH,
        fipsStandard: SYMCRYPT_DLGROUP_FIPS,
        pDlgroup: PSYMCRYPT_DLGROUP,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlgroupSetValueSafePrime(
        dhSafePrimeType: SYMCRYPT_DLGROUP_DH_SAFEPRIMETYPE,
        pDlgroup: PSYMCRYPT_DLGROUP,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlgroupIsSame(
        pDlgroup1: PCSYMCRYPT_DLGROUP,
        pDlgroup2: PCSYMCRYPT_DLGROUP,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptDlgroupGetSizes(
        pDlgroup: PCSYMCRYPT_DLGROUP,
        pcbPrimeP: *mut SIZE_T,
        pcbPrimeQ: *mut SIZE_T,
        pcbGenG: *mut SIZE_T,
        pcbSeed: *mut SIZE_T,
    );
}
extern "C" {
    pub fn SymCryptDlgroupSetValue(
        pbPrimeP: PCBYTE,
        cbPrimeP: SIZE_T,
        pbPrimeQ: PCBYTE,
        cbPrimeQ: SIZE_T,
        pbGenG: PCBYTE,
        cbGenG: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        pHashAlgorithm: PCSYMCRYPT_HASH,
        pbSeed: PCBYTE,
        cbSeed: SIZE_T,
        genCounter: UINT32,
        fipsStandard: SYMCRYPT_DLGROUP_FIPS,
        pDlgroup: PSYMCRYPT_DLGROUP,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlgroupGetValue(
        pDlgroup: PCSYMCRYPT_DLGROUP,
        pbPrimeP: PBYTE,
        cbPrimeP: SIZE_T,
        pbPrimeQ: PBYTE,
        cbPrimeQ: SIZE_T,
        pbGenG: PBYTE,
        cbGenG: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ppHashAlgorithm: *mut PCSYMCRYPT_HASH,
        pbSeed: PBYTE,
        cbSeed: SIZE_T,
        pGenCounter: PUINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlkeySetPrivateKeyLength(
        pkDlkey: PSYMCRYPT_DLKEY,
        nBitsPriv: UINT32,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlkeyGetGroup(pkDlkey: PCSYMCRYPT_DLKEY) -> PCSYMCRYPT_DLGROUP;
}
extern "C" {
    pub fn SymCryptDlkeySizeofPublicKey(pkDlkey: PCSYMCRYPT_DLKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptDlkeySizeofPrivateKey(pkDlkey: PCSYMCRYPT_DLKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptDlkeyHasPrivateKey(pkDlkey: PCSYMCRYPT_DLKEY) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptDlkeyGenerate(flags: UINT32, pkDlkey: PSYMCRYPT_DLKEY) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlkeySetValue(
        pbPrivateKey: PCBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PCBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pkDlkey: PSYMCRYPT_DLKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlkeyGetValue(
        pkDlkey: PCSYMCRYPT_DLKEY,
        pbPrivateKey: PBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDlkeyExtendKeyUsage(pkDlkey: PSYMCRYPT_DLKEY, flags: UINT32) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcurvePrivateKeyDefaultFormat(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveHighBitRestrictionNumOfBits(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveHighBitRestrictionPosition(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveHighBitRestrictionValue(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveBitsizeofFieldModulus(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveBitsizeofGroupOrder(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveSizeofFieldElement(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveSizeofScalarMultiplier(pCurve: PCSYMCRYPT_ECURVE) -> UINT32;
}
extern "C" {
    pub fn SymCryptEcurveIsSame(pCurve1: PCSYMCRYPT_ECURVE, pCurve2: PCSYMCRYPT_ECURVE) -> BOOLEAN;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP192: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP224: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP256: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP384: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNistP521: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNumsP256t1: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNumsP384t1: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsNumsP512t1: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub static SymCryptEcurveParamsCurve25519: PCSYMCRYPT_ECURVE_PARAMS;
}
extern "C" {
    pub fn SymCryptEckeySizeofPublicKey(
        pkEckey: PCSYMCRYPT_ECKEY,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
    ) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeySizeofPrivateKey(pkEckey: PCSYMCRYPT_ECKEY) -> UINT32;
}
extern "C" {
    pub fn SymCryptEckeyHasPrivateKey(pkEckey: PCSYMCRYPT_ECKEY) -> BOOLEAN;
}
extern "C" {
    pub fn SymCryptEckeySetValue(
        pbPrivateKey: PCBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PCBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
        pEckey: PSYMCRYPT_ECKEY,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeySetRandom(flags: UINT32, pEckey: PSYMCRYPT_ECKEY) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeyGetValue(
        pEckey: PCSYMCRYPT_ECKEY,
        pbPrivateKey: PBYTE,
        cbPrivateKey: SIZE_T,
        pbPublicKey: PBYTE,
        cbPublicKey: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        ecPointFormat: SYMCRYPT_ECPOINT_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEckeyExtendKeyUsage(pEckey: PSYMCRYPT_ECKEY, flags: UINT32) -> SYMCRYPT_ERROR;
}
extern "C" {
    #[doc = " Crypto algorithm API *"]
    pub fn SymCryptRsaRawEncrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaRawDecrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        numFormat: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Encrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Decrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaOaepEncrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        nfDst: SYMCRYPT_NUMBER_FORMAT,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaOaepDecrypt(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbSrc: PCBYTE,
        cbSrc: SIZE_T,
        nfSrc: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        pbLabel: PCBYTE,
        cbLabel: SIZE_T,
        flags: UINT32,
        pbDst: PBYTE,
        cbDst: SIZE_T,
        pcbDst: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_OID {
    pub cbOID: UINT32,
    pub pbOID: PCBYTE,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_OID() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_OID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_OID>(),
        16usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_OID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_OID>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_OID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cbOID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_OID),
            "::",
            stringify!(cbOID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pbOID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_OID),
            "::",
            stringify!(pbOID)
        )
    );
}
pub type SYMCRYPT_OID = _SYMCRYPT_OID;
pub type PSYMCRYPT_OID = *mut _SYMCRYPT_OID;
pub type PCSYMCRYPT_OID = *const SYMCRYPT_OID;
extern "C" {
    pub static SymCryptMd5OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha1OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha512OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_256OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_384OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub static SymCryptSha3_512OidList: [SYMCRYPT_OID; 2usize];
}
extern "C" {
    pub fn SymCryptRsaPkcs1Sign(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pHashOIDs: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPkcs1Verify(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pHashOID: PCSYMCRYPT_OID,
        nOIDCount: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPssSign(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
        pcbSignature: *mut SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaPssVerify(
        pkRsakey: PCSYMCRYPT_RSAKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        nfSignature: SYMCRYPT_NUMBER_FORMAT,
        hashAlgorithm: PCSYMCRYPT_HASH,
        cbSalt: SIZE_T,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptRsaSelftest();
}
extern "C" {
    pub fn SymCryptDsaSign(
        pKey: PCSYMCRYPT_DLKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDsaVerify(
        pKey: PCSYMCRYPT_DLKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDsaSelftest();
}
extern "C" {
    pub fn SymCryptDhSecretAgreement(
        pkPrivate: PCSYMCRYPT_DLKEY,
        pkPublic: PCSYMCRYPT_DLKEY,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbAgreedSecret: PBYTE,
        cbAgreedSecret: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptDhSecretAgreementSelftest();
}
extern "C" {
    pub fn SymCryptEcDsaSign(
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbSignature: PBYTE,
        cbSignature: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDsaVerify(
        pKey: PCSYMCRYPT_ECKEY,
        pbHashValue: PCBYTE,
        cbHashValue: SIZE_T,
        pbSignature: PCBYTE,
        cbSignature: SIZE_T,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDsaSelftest();
}
extern "C" {
    pub fn SymCryptEcDhSecretAgreement(
        pkPrivate: PCSYMCRYPT_ECKEY,
        pkPublic: PCSYMCRYPT_ECKEY,
        format: SYMCRYPT_NUMBER_FORMAT,
        flags: UINT32,
        pbAgreedSecret: PBYTE,
        cbAgreedSecret: SIZE_T,
    ) -> SYMCRYPT_ERROR;
}
extern "C" {
    pub fn SymCryptEcDhSecretAgreementSelftest();
}
extern "C" {
    pub fn SymCryptFatal(fatalCode: UINT32);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYMCRYPT_UINT32_MAP {
    pub from: UINT32,
    pub to: UINT32,
}
#[test]
fn bindgen_test_layout__SYMCRYPT_UINT32_MAP() {
    const UNINIT: ::std::mem::MaybeUninit<_SYMCRYPT_UINT32_MAP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SYMCRYPT_UINT32_MAP>(),
        8usize,
        concat!("Size of: ", stringify!(_SYMCRYPT_UINT32_MAP))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYMCRYPT_UINT32_MAP>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYMCRYPT_UINT32_MAP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_UINT32_MAP),
            "::",
            stringify!(from)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYMCRYPT_UINT32_MAP),
            "::",
            stringify!(to)
        )
    );
}
pub type SYMCRYPT_UINT32_MAP = _SYMCRYPT_UINT32_MAP;
pub type PSYMCRYPT_UINT32_MAP = *mut _SYMCRYPT_UINT32_MAP;
pub type PCSYMCRYPT_UINT32_MAP = *const SYMCRYPT_UINT32_MAP;
extern "C" {
    pub fn SymCryptMapUint32(
        u32Input: UINT32,
        u32Default: UINT32,
        pcMap: PCSYMCRYPT_UINT32_MAP,
        nMap: SIZE_T,
    ) -> UINT32;
}
